å‡å¦‚æˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ª `Runner`ç±»å¦‚ä¸‹ï¼Œå¤–ç•Œå¯ä»¥é€šè¿‡è°ƒç”¨`exec`æ–¹æ³•æ¥æ‰§è¡Œå†…éƒ¨é€»è¾‘è¿›è¡Œ`builSomething`çš„æ“ä½œã€‚å¦‚ä¸‹ï¼š

```
class Runner {
    exec() {
        buildSomething()
    }
}
function buildSomething() {
    console.log('buildSomething')
}
```

è¿™å¾ˆå®¹æ˜“ç†è§£ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬æƒ³è¦åœ¨è¿›è¡Œ`buildSomething`ä¹‹å‰æ¥è¿›è¡Œä¸€äº›å‰æœŸçš„å‡†å¤‡å·¥ä½œï¼Œå¦‚å‡†å¤‡`node`ç¯å¢ƒæˆ–è€…`yarn`ã€‚æ›´æ”¹ä»£ç å¦‚ä¸‹:

```
class Runner {
    exec() {
        prepareNode()
        prepareYarn()
        buildSomething()
    }
}
function prepareNode() {
    console.log('prepareNode')
}
function prepareYarn() {
    console.log('prepareYarn')
}

function buildSomething() {
    console.log('buildSomething')
}
```

æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°å¯ä»¥æŠ½ç¦»å‡ºæ¥ä¸€ä¸ª`prepare`å‡½æ•°ï¼Œå°†æ‰€æœ‰çš„å‡†å¤‡å·¥ä½œéƒ½ä¸¢åœ¨`prepare`å‡½æ•°ä¸­ï¼Œæ¥ä¿è¯`Runner`ç±»çš„çº¯ç²¹ã€‚å¦‚ä¸‹ï¼š

```
class Runner {
    exec() {
        prepare()
        buildSomething()
    }
}
function prepare() {
    prepareNode()
    prepareYarn()
}
```

ä½†æ˜¯æ­¤æ—¶æˆ‘ä»¬æœ‰äº†æ›´å¤æ‚çš„éœ€æ±‚ï¼Œå‡å¦‚åœ¨`exec`æ‰§è¡Œä¹‹å‰å¯èƒ½æ˜¯æ‰§è¡Œ`prepareNode`æ“ä½œï¼Œä¹Ÿå¯èƒ½æ˜¯`prepareYarn`è¿˜æœ‰å¯èƒ½æ˜¯ä¸¤è€…éƒ½è¦è¿›è¡Œå‡†å¤‡ã€‚ç»§ç»­æ›´æ”¹ä»£ç å¦‚ä¸‹ï¼š

```
interface Options {
    shouldPrepareNode: boolean,
    shouldPrepareYarn: boolean
}
class Runner {
    protected shouldPrepareNode: boolean
    protected shouldPrepareYarn: boolean
    constructor(options: Options) {
        this.shouldPrepareNode = options.shouldPrepareNode
        this.shouldPrepareYarn = options.shouldPrepareYarn
    }
    exec() {
        prepare.call(this)
        buildSomething()
    }
}
function prepare(this: Runner) {
    this.shouldPrepareNode && prepareNode()
    this.shouldPrepareNode && prepareYarn()
}
```

**æ­¤æ—¶å·²ç»å®ç°äº†æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä½†æ˜¯éœ€æ±‚æ˜¯æ— æ­¢å°½çš„ï¼** ç°åœ¨æˆ‘è¦åœ¨`exec`ä¹‹å‰æ‰§è¡Œ`install`æ“ä½œã€‚æˆ–è€…æˆ‘æƒ³è¦åœ¨`exec`ä¹‹å‰æ‰§è¡Œä»»ä½•å…¶ä»–ä¸ç¡®å®šçš„æ“ä½œã€‚é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å¦‚ä½•å¤„ç†`Runner`ç±»å‘¢ï¼Œæ— é™åˆ¶çš„å¢åŠ `shouldPrepareInstall`æˆ–è€…æ— å°½çš„`shouldPreparexxx`å‚æ•°ï¼Ÿä¸€å®šä¸ä¼šæœ‰äººé€‰æ‹©è¿™ä¹ˆæ“ä½œï¼

## ç®€æ˜“çš„æ’ä»¶å®ç°

`Nodejs` ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ª`events`æ¨¡å—ï¼Œç°åœ¨æˆ‘ä»¬é€šè¿‡`events`æ¨¡å—æ¥ä¼˜åŒ–æœ€åˆçš„ä»£ç ï¼š

```
class Runner {
    private ee: EventEmitter
    constructor(options: Options) {
        this.ee = new EventEmitter()
        options.shouldPrepareNode && this.ee.on('prepare', () => {
            console.log('prepareNode')
        })
        options.shouldPrepareYarn && this.ee.on('prepare', () => {
            console.log('prepareYarn')
        })
    }
    exec() {
        this.ee.emit('prepare')
        buildSomething()
    }
}
function buildSomething() {
    console.log('buildSomething')
}
const runner = new Runner({ shouldPrepareNode: true, shouldPrepareYarn: false })
runner.exec() 
//  prepareNode
//  buildSomething
```

ä¸Šé¢æˆ‘ä»¬è¯´è¿‡ï¼Œæˆ‘ä»¬éœ€è¦æ»¡è¶³åœ¨`exec`æ‰§è¡Œä¹‹å‰èƒ½å¤Ÿæ‰§è¡Œä»»ä½•çš„æ“ä½œï¼Œä½†æ˜¯æˆ‘ä»¬ä¸å¯èƒ½ä¼šæ— é™åˆ¶çš„å¢åŠ `shouldPreparxxx`æ¥è¿›è¡Œå®ç°ã€‚é‚£ä¹ˆæ‰€æœ‰çš„`preparexxx`æ“ä½œéƒ½åº”è¯¥ä»¥å‚æ•°çš„å½¢å¼ä¼ å…¥ã€‚ç»§ç»­ä¼˜åŒ–æˆ‘ä»¬çš„ä»£ç å¦‚ä¸‹ï¼š

```
type Listener = (...args: any[]) => void
interface Options {
    prepareListeners: Listener[] | Listener,
}
class Runner {
    private ee: EventEmitter
    constructor(options: Options) {
        this.ee = new EventEmitter()
        if (Array.isArray(options.prepareListeners)) {
            for (const listener of options.prepareListeners) {
                this.ee.on('prepare', listener)
            }
        } else {
            this.ee.on('prepare', options.prepareListeners)
        }
    }
    exec() {
        this.ee.emit('prepare')
        buildSomething()
    }
}

const runner = new Runner({
    prepareListeners: [
        prepareNode,
        prepareYarn
    ]
})
runner.exec()
```

æ­¤æ—¶å·²ç»å®ç°äº†ä¸€ä¸ªç®€æ˜“ç‰ˆæœ¬çš„æ’ä»¶ç³»ç»Ÿï¼Œå¹¶ä¸”`Runner`å·²ç»æ˜¯ä¸€ä¸ªå¤æ‚åº¦å¯æ§çš„ç±»äº†ã€‚

## æ”¯æŒå¼‚æ­¥å‡½æ•°è°ƒç”¨

ç°åœ¨æ–°çš„éœ€æ±‚åˆæ¥äº†ï¼Œ`prapareNode` å’Œ`prepareYarn`æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„æ‰§è¡Œå‡½æ•°ã€‚æˆ‘ä»¬éœ€è¦åœ¨å¼‚æ­¥å‡½æ•°`prapareNode`å’Œ`prepareYarn`æ‰§è¡Œå®Œæ¯•ä¹‹åæ‰èƒ½å¤Ÿè°ƒç”¨ `buildSomething`çš„æ“ä½œã€‚å¦‚ä¸‹ï¼š

```
function sleep(wait: number) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(wait)
        }, wait);
    })
}
async function prepareNode() {
    await sleep(500)
    console.log('prepareNode')
}
async function prepareYarn() {
    await sleep(300)
    console.log('prepareYarn')
}
```

æ­¤æ—¶æˆ‘ä»¬çš„æ‰§è¡Œç»“æœä¸ºï¼š

```
buildSomething
prepareYarn
prepareNode
```

å¾ˆæ˜æ˜¾ï¼Œ`buildSomething` çš„æ‰§è¡Œæ—©äºäº†`preparexxx`ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„`emit`è¿‡ç¨‹å¹¶ä¸ä¼šè¢«`await`ï¼Œè®©æˆ‘ä»¬ç»§ç»­æ”¹é€ ä»£ç è®© `emit` å‡½æ•°å¯ä»¥è¢«`await`ã€‚å¦‚ä¸‹ï¼š

```
type Listener = (...args: any[]) => void
interface Options {
    prepareListeners: Listener[] | Listener,
}
type LifeCycle = 'prepare' | 'start' | 'end' | 'xxx'
interface Context {
    count: number,
    resolve: (value: unknown) => void
    reject: (value: unknown) => void
}
class Runner {
    private eventHandlerContext = new Map<LifeCycle, Context>()
    private ee: EventEmitter
    constructor(options: Options) {
        this.ee = new EventEmitter()
        if (Array.isArray(options.prepareListeners)) {
            for (const listener of options.prepareListeners) {
                this._on('prepare', listener)
            }
        } else {
            this._on('prepare', options.prepareListeners)
        }
    }
    async exec() {
        await this._emit('prepare')
        buildSomething()
    }
    private _on(eventName: LifeCycle, listener: Listener) {
        const wrapperListener = async (...args: any[]) => {
            const ctx = this.eventHandlerContext.get(eventName)!
            const ret = await listener(...args)
            this.eventHandlerContext.set(eventName, { ...ctx, count: ctx.count++ })
            // å¦‚æœlistener å…¨éƒ¨æ‰§è¡Œå®Œæ¯• ä»£è¡¨ on äº‹ä»¶æ‰§è¡Œå®Œæ¯•
            if (ctx.count === this.ee.listenerCount(eventName)) {
                ctx.resolve(true)
            }
            return ret
        }
        this.ee.on(eventName, wrapperListener)
    }
    private async _emit(eventName: LifeCycle, ...args: any[]) {
        const promise = new Promise((resolve, reject) => {
            this.eventHandlerContext.set(eventName, { reject, resolve, count: 0 })
        })
        this.ee.emit(eventName)
        await promise
    }
}
const runner = new Runner({
    prepareListeners: [
        prepareNode,
        prepareYarn
    ]
})
runner.exec()
```

æ­¤æ—¶ä»£ç çš„æ‰§è¡Œç»“æœå¦‚ä¸‹ï¼š

```
prepareYarn
prepareNode
build something
```

é€šè¿‡åŒ…è£…`EventEmitter`çš„`on`å’Œ`emit`äº‹ä»¶ï¼Œå¹¶ä¸”å†…ç½®äº†ä¸€ä¸ª`eventHandlerContext`æ¥å­˜å‚¨å‡½æ•°æ‰§è¡Œçš„çŠ¶æ€ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ”¯æŒå¼‚æ­¥çš„`preparexxx`äº†ã€‚

æ­¤æ—¶æ— è®ºä¼ å…¥çš„`preparexxx`æ˜¯å¼‚æ­¥æ“ä½œè¿˜æ˜¯åŒæ­¥æ“ä½œï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ä¿è¯`buildSomething`çš„æ‰§è¡Œæ˜¯åœ¨`parparexxx`å‡½æ•°æ‰§è¡Œå®Œæˆä¹‹åæ‰ä¼šè¢«è°ƒç”¨ã€‚

## æ”¯æŒå¼‚æ­¥ä¸²è¡Œæˆ–å¹¶è¡Œæ‰§è¡Œ

ä¸Šé¢ä»£ç çš„è¾“å‡ºä½ å¯èƒ½å·²ç»å‘ç°äº†é—®é¢˜ï¼Œç”±äº`prepareYarn`å‡½æ•°å†…éƒ¨å¼‚æ­¥ç­‰å¾…äº†`300ms`æ‰§è¡Œï¼Œä½†æ˜¯`prepareNode`å‡½æ•°å†…éƒ¨å¼‚æ­¥ç­‰å¾…äº†`500ms`æ‰§è¡Œï¼Œå¯¼è‡´ `prepareYarn` çš„è¾“å‡ºæ—©äº`prepareNode`ã€‚

è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä¸Šé¢çš„å®ç°ï¼Œå®é™…ä¸Šç±»ä¼¼äº`Promisea.all(listeners:Function[])`çš„æ“ä½œï¼Œåªæ˜¯ä¿è¯äº†`buildSomething`çš„æ“ä½œåœ¨`preparexxx`ä¹‹åæ‰§è¡Œã€‚

å¦‚æœæˆ‘ä»¬æƒ³è¦å®ç° `preparexxx` çš„é¡ºåºæ‰§è¡Œï¼Œå³ `prepareNode`===>`prepareYarn`===>`preparexxx`===>`buildSomething`ï¼Œå°±éœ€è¦ç±»ä¼¼ä¸‹é¢çš„æ“ä½œï¼š

```
for (const listener of listeners:Function[]) {
  await listener
}
```

ç»§ç»­æ›´æ”¹ä»£ç å¦‚ä¸‹

```
type Listener = (...args: any[]) => void
type EventName = 'prepare' | 'start' | 'end' | 'xxx'
interface Context {
    count: number,
    resolve: (value: unknown) => void
    reject: (value: unknown) => void
}
type EventType = 'parallel' | 'series'
interface Handler {
    type?: EventType,
    listeners: Listener[] | Listener
}
type Options = Partial<Record<EventName, Handler>>
class Runner {
    private eventHandlerContext = new Map<EventName, Context>()
    private eventNames: EventName[] = []
    private ee: EventEmitter
    private eventTypeStore = new Map<EventName, EventType>()
    private seriesListenersStore = new Map<EventName, Listener[]>()
    constructor(options: Options) {
        this.ee = new EventEmitter()
        this.eventNames = Object.keys(options) as EventName[]
        for (const eventName of this.eventNames) {
            const { type = 'parallel', listeners } = options[eventName]!
            this.eventTypeStore.set(eventName, type)
            const listenersArr = Array.isArray(listeners) ? listeners : [listeners]
            for (const listener of listenersArr) {
                this._on(eventName, listener)
            }
        }
    }
    async exec(...args: any[]) {
        for (const eventName of this.eventNames) {
            console.log(`-----------${eventName}ç”Ÿå‘½å‘¨æœŸæ‰§è¡Œ-----------`)
            await this._emit(eventName, ...args)
        }
        buildSomething()
    }
    private _on(eventName: EventName, listener: Listener) {
        const eventType = this.eventTypeStore.get(eventName)
        switch (eventType) {
            case 'parallel': {
                const wrapperListener = async (...args: any[]) => {
                    const ctx = this.eventHandlerContext.get(eventName)!
                    const ret = await listener(...args)
                    this.eventHandlerContext.set(eventName, { ...ctx, count: ctx.count++ })
                    // å¦‚æœlistener å…¨éƒ¨æ‰§è¡Œå®Œæ¯• ä»£è¡¨ on äº‹ä»¶æ‰§è¡Œå®Œæ¯•
                    if (ctx.count === this.ee.listenerCount(eventName)) {
                        ctx.resolve(true)
                    }
                    return ret
                }
                this.ee.on(eventName, wrapperListener)
                break;
            }
            case 'series': {
                this.ee.removeAllListeners(eventName)
                const listeners = (this.seriesListenersStore.get(eventName) || [])
                listeners.push(listener)
                this.seriesListenersStore.set(eventName, listeners)
                let wrapperListener = async (...args: any[]) => {
                    const ctx = this.eventHandlerContext.get(eventName)
                    const firstFn = listeners.shift()!
                    let result = await firstFn(...args)
                    for (const fn of listeners) {
                        result = await fn(result)
                    }
                    ctx?.resolve(true)
                }
                this.ee.on(eventName, wrapperListener)
                break
            }
            default:
                throw new Error(`unknown event type ${this.eventTypeStore.get(eventName)}`)
        }
    }
    private async _emit(eventName: EventName, ...args: any[]) {
        const promise = new Promise((resolve, reject) => {
            this.eventHandlerContext.set(eventName, { reject, resolve, count: 0 })
        })
        this.ee.emit(eventName, ...args)
        await promise
    }
}
const runner = new Runner({
    prepare: {
        listeners: [prepareNode, prepareYarn],
        type: 'parallel'
    },
    start: {
        listeners: [prepareNode, prepareYarn],
        type: 'series'
    },
    end: {
        listeners: [pipe1, pipe2],
        type: 'series'
    }
})

function pipe1(a: number, b: number) {
    console.log(a, b, 'pipe1æ‰§è¡Œ')
    return a + b
}
function pipe2(a: number) {
    console.log(a, 'pipe2æ‰§è¡Œ')
    return a * 2
}
runner.exec(1, 2)
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```
-----------prepareç”Ÿå‘½å‘¨æœŸæ‰§è¡Œ-----------
prepareYarn
prepareNode
-----------startç”Ÿå‘½å‘¨æœŸæ‰§è¡Œ-----------
prepareNode
prepareYarn
-----------endç”Ÿå‘½å‘¨æœŸæ‰§è¡Œ-----------
1 2 pipe1æ‰§è¡Œ
3 pipe2æ‰§è¡Œ
buildSomething
```

é€šè¿‡å¢åŠ ä¸€ä¸ªå‚æ•° `type` æ¥å—ä¸¤ç§ç±»å‹åˆ†åˆ«ä¸º`parallel`æˆ–`series`ï¼Œå®ç°äº†æ”¯æŒå¼‚æ­¥å‡½æ•°çš„å¹¶è¡Œæˆ–ä¸²è¡Œã€‚ç”šè‡³å®ç°äº†å¯ä»¥å°†ä¸Šä¸€ä¸ªå‡½æ•°çš„æ‰§è¡Œç»“æœä½œä¸ºä¸‹ä¸€ä¸ªå‡½æ•°çš„å‚æ•°ã€‚

è‡³æ­¤ä¸€ä¸ªæ”¯æŒåŒæ­¥ã€å¼‚æ­¥ã€å¹¶è¡Œã€ä¸²è¡Œçš„æ’ä»¶ç³»ç»Ÿå·²ç»å®Œæˆå•¦ ğŸ‰ğŸ‰ğŸ‰

## ç»ˆæå®ç° Tapable

`Tapable` æ˜¯`Webpack` å›¢é˜Ÿå¼€å‘çš„åŸºäºäº‹ä»¶é©±åŠ¨çš„æ’ä»¶æ¨¡å—ï¼Œ`Webpack` çš„`Plugins`æœºåˆ¶å°±æ˜¯åŸºäº`Tapable`å®ç°ã€‚ä¸‹é¢æˆ‘ä»¬ç”¨`Tapable`æ¥å®ç°ä¸€ä¸‹ä¸Šé¢çš„ä¾‹å­ã€‚

```
class TapableRunner {
  hooks: { prepare: AsyncParallelHook<void>, start: AsyncSeriesHook<void>, end: AsyncSeriesWaterfallHook<[number, number]> }
  constructor() {
    this.hooks = {
      prepare: new AsyncParallelHook(),
      start: new AsyncSeriesHook(),
      end: new AsyncSeriesWaterfallHook(['a', 'b'])
    }
  }
  async exec() {
    await this.hooks.prepare.promise()
    await this.hooks.start.promise()
    await this.hooks.end.promise(1, 2)
  }
}
const tapableRunner = new TapableRunner()
tapableRunner.hooks.prepare.tapPromise('prepareNode', prepareNode)
tapableRunner.hooks.prepare.tapPromise('prepareYarn', prepareYarn)
tapableRunner.hooks.start.tapPromise('prepareNode', prepareNode)
tapableRunner.hooks.start.tapPromise('prepareYarn', prepareYarn)
tapableRunner.hooks.end.tapPromise('pipe1', pipe1)
tapableRunner.hooks.end.tapPromise('pipe2', pipe2)
tapableRunner.exec()
```

è¾“å‡ºï¼š

```
prepareYarn
prepareNode
prepareNode
prepareYarn
1 2 pipe1æ‰§è¡Œ
3 pipe2æ‰§è¡Œ
```

è‡³æ­¤ï¼Œæˆ‘ä»¬è´¹åŠ²å®ç°çš„`Plugin`æœºåˆ¶ï¼Œé€šè¿‡`Tapable`çŸ­çŸ­20è¡Œä»£ç å·²ç»å®ç°äº†ã€‚

## æ€»ç»“

å¯¹äºä¸€äº›è¾ƒå¤æ‚çš„é¡¹ç›®ï¼Œæ’ä»¶åŒ–çš„å¼€å‘æ–¹å¼ï¼Œå¯ä»¥è®©æˆ‘ä»¬çš„é¡¹ç›®æ›´åŠ çµæ´»ï¼ŒåŒæ—¶æé«˜çš„å¢åŠ é¡¹ç›®çš„å¯ç»´æŠ¤æ€§ã€‚æˆ‘ä»¬å¸¸ç”¨çš„`Webpack`ã€`Rollup`ç­‰éƒ½å­˜åœ¨`Plugins`æœºåˆ¶çš„è®¾è®¡æ€æƒ³ã€‚é€šè¿‡å®šä¹‰å¥½ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼Œä¹‹åæš´éœ²ç»™å¤–éƒ¨ä»‹å…¥ï¼Œä»è€Œå®ç°äº†ä¸åŒçš„åŠŸèƒ½é€šè¿‡ä¸åŒçš„æ’ä»¶æ¥å®ç°çš„è¡Œä¸ºã€‚

é€šè¿‡ä¸€æ­¥æ­¥çš„å®ç°ä¸€ä¸ªè‡ªå·±çš„`Plugin`æœºåˆ¶ï¼Œåˆ°æœ€ç»ˆæ”¹ä¸ºé€šè¿‡`Tapable`å®ç°ï¼Œé€šè¿‡è¿™ä¸ªè¿‡ç¨‹ç›¸ä¿¡ä½ ä¹Ÿä¼šå¯¹`Webpack`çš„`Plugin`æœ‰æ›´å¥½çš„ç†è§£ã€‚