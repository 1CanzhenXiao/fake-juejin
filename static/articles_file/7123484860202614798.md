### 为什么需要内存模型

***

由于摩尔定律的失效，CPU的执行速度越来越快，由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。所以CPU向多核心多级缓存的方向发展。那这样就给软件开发者带来了线程安全问题。

因为存在不同的CPU厂商，而且没有统一的标准和规范，所以各家的CPU协议不同，实现逻辑也不尽相同，比如缓存一致性协议（MESI）。\
比如，C语言直接依赖于处理器，不同的处理器的运行结果不一样。

也正因为有了多级缓存，CPU不在直接读写内存，而且CPU应用指令执行优化技术，也给并发程序带来了原子性、可见性、有序性问题。

这时候就急需一种规范和技术来统一解决这一困境。就出现了内存模型的概念。
### 什么是内存模型

***

为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

### 什么是Java内存模型

***

Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

这个规则是需要cpu工程师和JVM工程师需要共同遵守的。试想，如果JVM厂商不遵守这个规范，各个厂商各自实现自己的指令重拍规则，那么同一份Java代码在不同的jdk环境下结果也是不同的。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。

### JMM规定

***

-   所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝
-   线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中
-   主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成
-   所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。

***

### Java内存模型的实现

***

我们所熟知的volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。\
如果没有这些关键字和工具类，那就需要我们自己去指定什么时候使用内存栅栏，自己实现并发工具，而现在我们只需要直接使用就可以了。

### happens-before原则

***

指令执行优化会对一些指令进行重排序，但是是有原则的，这个就是happens-before原则，如下：

-   程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
-   锁定规则：一个unLock解锁操作先行发生于后面对同一个锁lock操作；
-   volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
-   传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
-   线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
-   线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
-   线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
-   对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

###### 工具类的happens-before原则

-   将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作
-   将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作
-   在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作
-   释放Semaphore许可的操作Happens-Before获得许可操作
-   Future表示的任务的所有操作Happens-Before Future#get()操作
-   向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作

我们对以上规则再做一些解读：

1、单线程规则\
     后面的语句一定能看到前面的语句做的事， 但是不影响重排序原则，重排序后后面的语句依然看到前面语句的操作

2、锁操作\
     A线程先加锁，B线程后加锁，B线程拿到锁后一定能看到A线程解锁前的所有操作

3、volatile变量\
     只要A线程写入了变量值那么B读取一定能看到最新值

4、线程启动\
     子线程启动一定能看到主线程的所有操作结果

5、线程join\
     在主线程中，join后面的语句一定能看到子线程所有的执行结果