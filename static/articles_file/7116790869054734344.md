- [æ–‡ç« èƒŒæ™¯](#%E8%83%8C%E6%99%AF)
- [1. What? openGlæ˜¯ä»€ä¹ˆï¼ŸopenGl ESåˆæ˜¯ä»€ä¹ˆï¼Ÿ](#1-what-opengl%E6%98%AF%E4%BB%80%E4%B9%88opengl-es%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88)
- [2. How? Androidä¸­çš„openGL å¦‚ä½•ä½¿ç”¨ï¼Ÿ](#2-how-android%E4%B8%AD%E7%9A%84opengl-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8)
- [3. GlSurfaceViewæ˜¯ä»€ä¹ˆï¼Ÿ GLSurfaceViewçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ GLSurfaceViewå¦‚ä½•ä½¿ç”¨ï¼Ÿ](#3-glsurfaceview%E6%98%AF%E4%BB%80%E4%B9%88-glsurfaceview%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-glsurfaceview%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8)
- [4. GlSurfaceView.Rendereræ˜¯ä»€ä¹ˆï¼ŸGLSurfaceView.Rendererçš„ä½œç”¨ï¼ŸGLSurfaceView.Rendererçš„ç”¨æ³•ï¼Ÿ](#4-glsurfaceviewrenderer%E6%98%AF%E4%BB%80%E4%B9%88glsurfaceviewrenderer%E7%9A%84%E4%BD%9C%E7%94%A8glsurfaceviewrenderer%E7%9A%84%E7%94%A8%E6%B3%95)
- [5. OpenGlçš„ç®€å•ä½¿ç”¨å®ä¾‹ï¼ˆç»˜åˆ¶ä¸€ä¸ªä¸‰è§’å½¢ï¼‰](#5-opengl%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2)
    - [ä½¿ç”¨OpenGlä¿®æ”¹èƒŒæ™¯é¢œè‰²](#%E4%BD%BF%E7%94%A8opengl%E4%BF%AE%E6%94%B9%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2)
    - [ä½¿ç”¨OpenGlç»˜åˆ¶å‡ ä½•å›¾å½¢](#%E4%BD%BF%E7%94%A8opengl%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2)
    - [è¿ç”¨æŠ•å½±å’Œç›¸æœºè§†å›¾](#%E8%BF%90%E7%94%A8%E6%8A%95%E5%BD%B1%E5%92%8C%E7%9B%B8%E6%9C%BA%E8%A7%86%E5%9B%BE)
        - [æŠ•å½±çš„å®šä¹‰](#%E6%8A%95%E5%BD%B1%E7%9A%84%E5%AE%9A%E4%B9%89)
        - [ç›¸æœºè§†å›¾](#%E7%9B%B8%E6%9C%BA%E8%A7%86%E5%9B%BE)
        - [è½¬æ¢çŸ©é˜µï¼ˆå˜æ¢çŸ©é˜µï¼‰](#%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5)
    - [æ·»åŠ åŠ¨ä½œ](#%E6%B7%BB%E5%8A%A0%E5%8A%A8%E4%BD%9C)
    - [ä¿®æ”¹é¡¶ç‚¹é¢œè‰²](#%E4%BF%AE%E6%94%B9%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2)
        - [shaderçš„å˜é‡ç±»å‹(uniformï¼Œattributeå’Œvarying)çš„åŒºåˆ«](#shader%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8Buniformattribute%E5%92%8Cvarying%E7%9A%84%E5%8C%BA%E5%88%AB)
- [6. å‚è€ƒé“¾æ¥ï¼š](#6-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5)
- [7. é¡¹ç›®åœ°å€ï¼š](#7-%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80)
```
~~åæ§½ä¸€ä¸‹æ˜é‡‘çš„markdownç¼–è¾‘å™¨ï¼Œå¥½ä¸å®¹æ˜“ææˆç›®å½•äº†å´åªèƒ½çœ‹ä¸èƒ½ç‚¹ï¼Œå¥½ä¼¤å¿ƒï¼Œè¿™å•¥æ—¶å€™ä¼˜åŒ–ä¸€ä¸‹ï¼ŸğŸ˜­ï¼Œæœ‰æœ¨æœ‰äººæ¥è§£å†³ä¸€ä¸‹ï¼Œå¼ºè¿«ç—‡è¡¨ç¤ºå¥½éš¾å—~~
```

## èƒŒæ™¯
æœ€è¿‘æ˜é‡‘ç­¾çº¦æ´»åŠ¨æ•´æå¾—çƒ­ç«æœå¤©ï¼Œç´¢æ€§æ‘Šå¼€åŒæ‰‹ï¼Œç¿»å¼€æˆ‘é‚£å°˜å°è®¸ä¹…ç¬”è®°æœ¬ï¼ŒæŠ±ç€è¯•è¯•çœ‹çš„æ€åº¦ï¼ŒæŠŠå‡ ç¯‡æ›¾ç»è‡ªå·±ç”¨å¿ƒæ•´ç†çš„æ–‡ç« æ‹‰å‡ºæ¥é›é›ï¼Œä¸‡ä¸€èƒ½æ•´æ¯å’–å•¡ï¼Œé‚£ä¹Ÿæ˜¯æ„æ–™ä¹‹å¤–çš„æƒŠå–œã€‚OKï¼Œèƒ½åŠ›ä¸€èˆ¬ï¼Œæ°´å¹³æœ‰é™ï¼Œå¦‚æœ‰åŒè¡Œå‘ç°æ–‡ç« æœ‰ä¸ä¸¥è°¨è®²ç©¶ä¹‹å¤„ï¼Œæ¬¢è¿æŒ‡æ­£æ‰¹åˆ¤ã€‚



>å­¦ä¹ äº”éƒ¨æ›²ï¼Œå¼„æ¸…æ¥š5ä¸ªWä¸€ä¸ªH(when(ä»€ä¹ˆæ—¶å€™ä½¿ç”¨)ã€whereï¼ˆåœ¨å“ªä¸ªåœ°æ–¹ä½¿ç”¨ï¼Ÿï¼‰ã€whoï¼ˆå¯¹è°ä½¿ç”¨ï¼‰ã€whatï¼ˆæ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ï¼‰ã€whyï¼ˆä¸ºä»€ä¹ˆè¦è¿™ä¹ˆç”¨ï¼Ÿï¼‰.ä¸€ä¸ªHå³ï¼šhowï¼ˆåˆ°åº•è¯¥æ€ä¹ˆç”¨ï¼Ÿ)ï¼Œæœ¬æ–‡ä¸»è¦å›´ç»•è¿™å‡ ä¸ªæ–¹é¢å¯¹OpenGLè¿›è¡Œåˆ†æè®²è§£ï¼Œå¸Œæœ›å¯¹æœ‰å…´è¶£äº†è§£çš„OpenGLçš„å°ä¼™ä¼´ä¸€ä¸¢ä¸¢å¸®åŠ©ã€‚

## 1. What? openGlæ˜¯ä»€ä¹ˆï¼ŸopenGl ESåˆæ˜¯ä»€ä¹ˆï¼Ÿ

ç›¸ä¿¡å¾ˆå¤šäººä»äº‹å¼€å‘çš„éƒ½æˆ–å¤šæˆ–å°‘å¬åˆ°è¿‡æœ‰å…³OpenGlè¿™ä¸ªä¸œè¥¿ï¼Œä½†æ˜¯å¹³æ—¶ç”¨çš„å°‘ï¼ŒåªçŸ¥é“æœ‰è¿™ä¹ˆä¸ªä¸œè¥¿ï¼Œè€Œä¸”å­¦èµ·æ¥ä¸ç®€å•ï¼Œæ‰€ä»¥å¤§å¤šæ•°äººéƒ½ä¸èƒ½è®²å‡ºä¸ªä¸ªæ‰€ä»¥ç„¶æ¥ã€‚

å®˜æ–¹å¯¹OpenGlçš„æè¿°ä¸ºï¼š

> OpenGL(Open Graphics Libraryå¼€å‘å›¾å½¢æ¥å£)æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„å›¾å½¢APIï¼Œç”¨äºæŒ‡å®š3Då›¾å½¢å¤„ç†ç¡¬ä»¶ä¸­çš„æ ‡å‡†è½¯ä»¶æ¥å£ã€‚

OpenGlçš„å‰èº«æ˜¯SGIå…¬å¸ä¸ºå…¶å›¾å½¢å·¥ä½œç«™å¼€å‘çš„IRIS GL,åæ¥å› ä¸ºIRIS GLçš„ç§»æ¤æ€§ä¸å¥½ï¼Œæ‰€ä»¥åœ¨å…¶åŸºç¡€ä¸Šï¼Œå¼€å‘å‡ºäº†OpenGlã€‚OpenGlä¸€èˆ¬ç”¨äºåœ¨å›¾å½¢å·¥ä½œç«™ï¼ŒPCç«¯ä½¿ç”¨ï¼Œç”±äºæ€§èƒ½å„æ–¹é¢åŸå› ï¼Œåœ¨ç§»åŠ¨ç«¯ä½¿ç”¨OpenGlåŸºæœ¬å¸¦ä¸åŠ¨ã€‚ä¸ºæ­¤ï¼ŒKhronoså…¬å¸å°±ä¸ºOpenGlæä¾›äº†ä¸€ä¸ªå­é›†ï¼ŒOpenGl ES(OpenGl for Embedded System)

ä»€ä¹ˆæ˜¯OpenGl ESå‘¢ï¼Ÿ

> OpenGl ESæ˜¯å…è´¹çš„è·¨å¹³å°çš„åŠŸèƒ½å®Œå–„çš„2D/3Då›¾å½¢åº“æ¥å£çš„API,æ˜¯OpenGLçš„ä¸€ä¸ªå­é›†ã€‚

ç§»åŠ¨ç«¯ä½¿ç”¨åˆ°çš„åŸºæœ¬ä¸Šéƒ½æ˜¯OpenGl ESï¼Œå½“ç„¶Androidå¼€å‘ä¸‹è¿˜ä¸“é—¨ä¸ºOpenGlæä¾›äº†android.openglåŒ…ï¼Œå¹¶ä¸”æä¾›äº†GlSurfaceView,GLU,GlUtilsç­‰å·¥å…·ç±»ã€‚

## 2. How? Androidä¸­çš„openGL å¦‚ä½•ä½¿ç”¨ï¼Ÿ

åœ¨äº†è§£OpenGlçš„ä½¿ç”¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸¤ä¸ªåŸºæœ¬ç±»åˆ«çš„Androidæ¡†æ¶ï¼šGlSurfaceViewå’ŒGlSurfaceView.Renderer

## 3. GlSurfaceViewæ˜¯ä»€ä¹ˆï¼Ÿ GLSurfaceViewçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ GLSurfaceViewå¦‚ä½•ä½¿ç”¨ï¼Ÿ

> GlSurfaceViewä»åå­—å°±å¯ä»¥çœ‹å‡ºï¼Œå®ƒæ˜¯ä¸€ä¸ªSurfaceViewï¼Œçœ‹æºç å¯çŸ¥ï¼ŒGlSurfaceViewç»§æ‰¿è‡ªSurfaceViewã€‚å¹¶å¢åŠ äº†Renderer.å®ƒçš„ä½œç”¨å°±æ˜¯ä¸“é—¨ä¸ºOpenGlæ˜¾ç¤ºæ¸²æŸ“ä½¿ç”¨çš„ã€‚

GLSurfaceViewçš„ä½¿ç”¨æ–¹æ³•ï¼š å¯ä»¥é€šè¿‡åˆ›å»ºçš„å®ä¾‹ä½¿ç”¨è¿™ä¸ªç±»ï¼Œå¹¶å¢åŠ ä½ çš„Renderer.

```
@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        GLSurfaceView glSurfaceView = new GLSurfaceView(this);
        glSurfaceView.setRenderer(new GLSurfaceView.Renderer() {
            @Override
            public void onSurfaceCreated(GL10 gl, EGLConfig config) {

            }

            @Override
            public void onSurfaceChanged(GL10 gl, int width, int height) {

            }

            @Override
            public void onDrawFrame(GL10 gl) {

            }
        });
        setContentView(glSurfaceView);
    }
```

## 4. GlSurfaceView.Rendereræ˜¯ä»€ä¹ˆï¼ŸGLSurfaceView.Rendererçš„ä½œç”¨ï¼ŸGLSurfaceView.Rendererçš„ç”¨æ³•ï¼Ÿ

> è¯¥æ¥å£å®šä¹‰äº†ç”¨äºç»˜åˆ¶åœ¨å›¾å½¢æ‰€éœ€çš„æ–¹æ³•GLSurfaceViewã€‚ä½ å¿…é¡»æä¾›è¿™ä¸ªæ¥å£ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„ç±»çš„å®ç°ï¼Œå¹¶å°†å…¶è¿æ¥åˆ°æ‚¨çš„GLSurfaceViewä½¿ç”¨å®ä¾‹ GLSurfaceView.setRenderer()ã€‚å¦‚ä¸Šé¢çš„ä»£ç æ‰€ç¤ºã€‚ä½œç”¨å°±æ˜¯æä¾›å„ç§æ¸²æŸ“æ–¹æ³•ï¼ŒOpenGlçš„æ¸²æŸ“æ“ä½œå‡åœ¨æ­¤æ¥å£ä¸­å®ä¹ ã€‚ä¸‹é¢è¯´ä¸‹å®ç°è¯¥æ¥å£çš„æ–¹æ³•å«ä¹‰ï¼š

-   onSurfaceCreated()ï¼šç³»ç»Ÿè°ƒç”¨è¿™ä¸ªæ–¹æ³•ä¸€æ¬¡åˆ›å»ºæ—¶GLSurfaceViewã€‚ä½¿ç”¨æ­¤æ–¹æ³•æ¥æ‰§è¡Œåªéœ€è¦å‘ç”Ÿä¸€æ¬¡çš„æ“ä½œï¼Œæ¯”å¦‚è®¾ç½®OpenGLçš„ç¯å¢ƒå‚æ•°æˆ–åˆå§‹åŒ–çš„OpenGLå›¾å½¢å¯¹è±¡ã€‚
-   onDrawFrame()ï¼šç³»ç»Ÿè°ƒç”¨ä¸Šçš„æ¯ä¸ªé‡ç»˜æ­¤æ–¹æ³•GLSurfaceViewã€‚ä½¿ç”¨æ­¤æ–¹æ³•ä½œä¸ºä¸»è¦æ‰§è¡Œç‚¹ç”¨äºç»˜åˆ¶ï¼ˆå’Œé‡æ–°ç»˜åˆ¶ï¼‰çš„å›¾å½¢å¯¹è±¡ã€‚
-   ç³»ç»Ÿè°ƒç”¨æ­¤æ–¹æ³•æ—¶çš„GLSurfaceViewå‡ ä½•å½¢çŠ¶çš„å˜åŒ–ï¼ŒåŒ…æ‹¬å°ºå¯¸å˜åŒ–GLSurfaceViewæˆ–è®¾å¤‡å±å¹•çš„å–å‘ã€‚ä¾‹å¦‚ï¼Œå½“è®¾å¤‡ä»çºµå‘å˜ä¸ºæ¨ªå‘çš„ç³»ç»Ÿè°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚ä½¿ç”¨æ­¤æ–¹æ³•å¯ä»¥åœ¨å˜åŒ–åšå‡ºååº”GLSurfaceViewå®¹å™¨ã€‚

ä»‹ç»å®Œäº†GlSurfaceViewå’ŒGlSurfaceView.rendererä¹‹åï¼Œæ¥ä¸‹æ¥è¯´ä¸‹å¦‚ä½•ä½¿ç”¨GlSurfaceView; 1. åˆ›å»ºä¸€ä¸ªGlSurfaceView 2. ä¸ºè¿™ä¸ªGlSurfaceViewè®¾ç½®æ¸²æŸ“ 3. åœ¨GlSurfaceView.rendererä¸­ç»˜åˆ¶å¤„ç†æ˜¾ç¤ºæ•°æ®

## 5. OpenGlçš„ç®€å•ä½¿ç”¨å®ä¾‹ï¼ˆç»˜åˆ¶ä¸€ä¸ªä¸‰è§’å½¢ï¼‰

1.  åœ¨ä½¿ç”¨OpenGlä¹‹å‰ï¼Œéœ€è¦åœ¨AndroidManifest.xmlä¸­è®¾ç½®OpenGlçš„ç‰ˆæœ¬ï¼šè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯OpenGl ES 2.0,æ‰€ä»¥éœ€è¦æ·»åŠ å¦‚ä¸‹è¯´æ˜ï¼š

```
<uses-feature android:glEsVersion="0x00020000" android:required="true" />
```
1.  ä½¿ç”¨GLSufaceView(ä¸Šé¢æœ‰ä»‹ç»)
1.  å…·ä½“åœ¨GlSurfaceView.Rendererä¸­çš„ç»˜åˆ¶æ­¥éª¤ï¼š

-   è®¾ç½®è§†å›¾å±•ç¤ºçª—å£(viewport) :åœ¨onSurfaceChangedä¸­è°ƒç”¨GLES20.glViewport(0, 0, width, height);
-   åˆ›å»ºå›¾å½¢ç±»ï¼Œç¡®å®šå¥½é¡¶ç‚¹ä½ç½®å’Œå›¾å½¢é¢œè‰²ï¼Œå°†é¡¶ç‚¹å’Œé¢œè‰²æ•°æ®è½¬æ¢ä¸ºOpenGlä½¿ç”¨çš„æ•°æ®æ ¼å¼
-   åŠ è½½é¡¶ç‚¹æ‰¾è‰²å™¨å’Œç‰‡æ®µç€è‰²å™¨ç”¨æ¥ä¿®æ”¹å›¾å½¢çš„é¢œè‰²ï¼Œçº¹ç†ï¼Œåæ ‡ç­‰å±æ€§
-   åˆ›å»ºæŠ•å½±å’Œç›¸æœºè§†å›¾æ¥æ˜¾ç¤ºè§†å›¾çš„æ˜¾ç¤ºçŠ¶æ€ï¼Œå¹¶å°†æŠ•å½±å’Œç›¸æœºè§†å›¾çš„è½¬æ¢ä¼ é€’ç»™ç€è‰²å™¨ã€‚
-   åˆ›å»ºé¡¹ç›®(Program),è¿æ¥é¡¶ç‚¹ç€è‰²å™¨ç‰‡æ®µç€è‰²å™¨ã€‚
-   å°†åæ ‡æ•°æ®ä¼ å…¥åˆ°OpenGl ESç¨‹åºä¸­ï¼š

## ä½¿ç”¨OpenGlä¿®æ”¹èƒŒæ™¯é¢œè‰²

åˆ›å»ºä¸€ä¸ªGlSurfaceViewï¼Œå¹¶ä¸ºå…¶è®¾ç½®æ¸²æŸ“OneGlRenderer;

```
public class OneGlSurfaceView extends GLSurfaceView {
    private final OneGlRenderer mRenderer;
    public OneGlSurfaceView(Context context) {
        super(context);
        // Create an OpenGL ES 2.0 context
        setEGLContextClientVersion(2);

        mRenderer = new OneGlRenderer();

        // Set the Renderer for drawing on the GLSurfaceView
        setRenderer(mRenderer);
    }
}
```

å®ç°æ¸²æŸ“æ¥å£

```
public class OneGlRenderer implements GLSurfaceView.Renderer {
    public void onSurfaceCreated(GL10 unused, EGLConfig config) {
        // Set the background frame color
        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    }

    public void onDrawFrame(GL10 unused) {
        // Redraw background color
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }

    public void onSurfaceChanged(GL10 unused, int width, int height) {
        GLES20.glViewport(0, 0, width, height);
    }
}
```

å±•ç¤ºæ¸²æŸ“åçš„GlSurfaceView

```
public class OneOpenGlActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        OneGlSurfaceView glSurfaceView = new OneGlSurfaceView(this);
        setContentView(glSurfaceView);
    }
}
```

æ•ˆæœå¦‚ä¸‹ï¼šå°±æ˜¯ç®€å•ç»™GlSurfaceViewæ¸²æŸ“ä¸€å±‚é»‘è‰²ã€‚

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a5d47d40c74cd7b96d6772332be6b4~tplv-k3u1fbpfcp-zoom-1.image)


## ä½¿ç”¨OpenGlç»˜åˆ¶å‡ ä½•å›¾å½¢

ä¸€ï¼šå›¾å½¢åˆ›å»º

> åˆ›å»ºä¸€ä¸ªå‡ ä½•å›¾å½¢ï¼ˆè¿™é‡Œä¸»è¦åˆ—ä¸¾ä¸‰è§’å½¢å’Œæ­£æ–¹å½¢ï¼‰ï¼Œéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œæˆ‘ä»¬è®¾ç½®å›¾å½¢çš„é¡¶ç‚¹åæ ‡åï¼Œéœ€è¦å°†é¡¶ç‚¹åæ ‡è½¬ä¸ºByteBuffer,è¿™æ ·OpenGlæ‰èƒ½è¿›è¡Œå›¾å½¢å¤„ç†ã€‚

ä¸‰è§’å½¢å›¾å½¢åˆ›å»ºï¼š

```
public class Triangle {

    private FloatBuffer vertexBuffer;

    // number of coordinates per vertex in this array
    static final int COORDS_PER_VERTEX = 3;
    static float triangleCoords[] = {   // in counterclockwise order:
             0.0f,  0.5f, 0.0f, // top
            -0.5f, -0.5f, 0.0f, // bottom left
             0.5f, -0.5f, 0.0f  // bottom right
    };

    // Set color with red, green, blue and alpha (opacity) values
    float color[] = { 255, 0, 0, 1.0f };

    public Triangle() {
       // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*4ï¼Œå› ä¸ºä¸€ä¸ªfloatå 4ä¸ªå­—èŠ‚
        ByteBuffer bb = ByteBuffer.allocateDirect(triangleCoords.length * 4);
        // æ•°ç»„æ’åˆ—ç”¨nativeOrder
        bb.order(ByteOrder.nativeOrder());
        // ä»ByteBufferåˆ›å»ºä¸€ä¸ªæµ®ç‚¹ç¼“å†²åŒº
        vertexBuffer = bb.asFloatBuffer();
        // å°†åæ ‡æ·»åŠ åˆ°FloatBuffer
        vertexBuffer.put(triangleCoords);
        // è®¾ç½®ç¼“å†²åŒºæ¥è¯»å–ç¬¬ä¸€ä¸ªåæ ‡
        vertexBuffer.position(0);
    }
}
```

æ­£æ–¹å‹å›¾ï¼š

```
public class Square {

    private FloatBuffer vertexBuffer;
    private ShortBuffer drawListBuffer;

    // number of coordinates per vertex in this array
    static final int COORDS_PER_VERTEX = 3;
    static float squareCoords[] = {
            -0.5f,  0.5f, 0.0f,   // top left
            -0.5f, -0.5f, 0.0f,   // bottom left
             0.5f, -0.5f, 0.0f,   // bottom right
             0.5f,  0.5f, 0.0f }; // top right

    private short drawOrder[] = { 0, 1, 2, 0, 2, 3 }; // order to draw vertices

    public Square() {
        // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*4ï¼Œå› ä¸ºä¸€ä¸ªfloatå 4ä¸ªå­—èŠ‚
        ByteBuffer bb = ByteBuffer.allocateDirect(squareCoords.length * 4);
        bb.order(ByteOrder.nativeOrder());
        vertexBuffer = bb.asFloatBuffer();
        vertexBuffer.put(squareCoords);
        vertexBuffer.position(0);

        // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*2ï¼Œå› ä¸ºä¸€ä¸ªshortå 2ä¸ªå­—èŠ‚
        ByteBuffer dlb = ByteBuffer.allocateDirect(drawOrder.length * 2);
        dlb.order(ByteOrder.nativeOrder());
        drawListBuffer = dlb.asShortBuffer();
        drawListBuffer.put(drawOrder);
        drawListBuffer.position(0);
    }
}
```

åˆ›å»ºå›¾å½¢åŸºæœ¬æ²¡ä»€ä¹ˆæŠ€å·§å¯è¨€ï¼ŒæŒ‰éƒ¨å°±ç­å°±è¡Œäº†ï¼Œä¸ºä»€ä¹ˆæ•°æ®éœ€è¦è½¬æ¢æ ¼å¼å‘¢ï¼Ÿä¸»è¦æ˜¯å› ä¸ºJavaçš„ç¼“å†²åŒºæ•°æ®å­˜å‚¨ç»“æ„ä¸ºå¤§ç«¯å­—èŠ‚åº(BigEdian)ï¼Œè€ŒOpenGlçš„æ•°æ®ä¸ºå°ç«¯å­—èŠ‚åºï¼ˆLittleEdianï¼‰,å› ä¸ºæ•°æ®å­˜å‚¨ç»“æ„çš„å·®å¼‚ï¼Œæ‰€ä»¥ï¼Œåœ¨Androidä¸­ä½¿ç”¨OpenGlçš„æ—¶å€™å¿…é¡»è¦è¿›è¡Œä¸‹è½¬æ¢ã€‚å½“ç„¶ï¼Œä¸€èˆ¬æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™éƒ½ä¼šåšä¸ªç®€å•çš„å·¥å…·ç±»ã€‚è¿™é‡Œæä¾›å‡ ä¸ªç®€å•çš„å°è£…ã€‚ï¼ˆå å‡ ä¸ªå­—èŠ‚å°±åˆå§‹åŒ–ByteBufferé•¿åº¦çš„æ—¶å€™*å‡ ï¼‰

\


1.  å°†int[]è½¬æˆIntBuffer

```
private IntBuffer intBufferUtil(int[] arr)
    {
        IntBuffer mBuffer;
        // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*4ï¼Œå› ä¸ºä¸€ä¸ªintå 4ä¸ªå­—èŠ‚
        ByteBuffer qbb = ByteBuffer.allocateDirect(arr.length * 4);
        // æ•°ç»„æ’åˆ—ç”¨nativeOrder
        qbb.order(ByteOrder.nativeOrder());
        mBuffer = qbb.asIntBuffer();
        mBuffer.put(arr);
        mBuffer.position(0);
        return mBuffer;
    }
```


1.  å°†float[]æ•°ç»„è½¬ä¸ºOpenGl æ‰€éœ€è¦çš„FloatBuffer

```
private FloatBuffer floatBufferUtil(float[] arr)
    {
        FloatBuffer mBuffer;
        // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*4ï¼Œå› ä¸ºä¸€ä¸ªintå 4ä¸ªå­—èŠ‚
        ByteBuffer qbb = ByteBuffer.allocateDirect(arr.length * 4);
        // æ•°ç»„æ’åˆ—ç”¨nativeOrder
        qbb.order(ByteOrder.nativeOrder());
        mBuffer = qbb.asFloatBuffer();
        mBuffer.put(arr);
        mBuffer.position(0);
        return mBuffer;
    }
```


1.  å½“ç„¶ï¼Œä¾è‘«èŠ¦ç”»ç“¢ï¼Œå¦‚ä½•å°†short[]è½¬ShortBufferè¿™ä¸ªå°±ç…§ç€å†™å°±okäº†

```
private ShortBuffer shortBufferUtil(short[] arr){
        ShortBuffer mBuffer;
        // åˆå§‹åŒ–ByteBufferï¼Œé•¿åº¦ä¸ºarræ•°ç»„çš„é•¿åº¦*2ï¼Œå› ä¸ºä¸€ä¸ªshortå 2ä¸ªå­—èŠ‚
        ByteBuffer dlb = ByteBuffer.allocateDirect(
                // (# of coordinate values * 2 bytes per short)
                arr.length * 2);
        dlb.order(ByteOrder.nativeOrder());
        mBuffer = dlb.asShortBuffer();
        mBuffer.put(arr);
        mBuffer.position(0);
        return mBuffer;
    }
```

åˆ›å»ºå®Œå½¢çŠ¶ä¹‹åï¼Œæˆ‘ä»¬å°±è¦è¿›è¡Œæˆ‘ä»¬çš„ç¬¬äºŒæ­¥äº†ï¼Œå°†è¿™äº›å½¢çŠ¶æ¸²æŸ“åˆ°GlSurfaceViewä¸­å»ã€‚ä¸»è¦å¯åˆ†ä¸ºä¸‹é¢å‡ æ­¥ï¼š 1. é¦–å…ˆæˆ‘ä»¬éœ€è¦åœ¨GlSurfaceView.Rendererä¸­åˆå§‹åŒ–éœ€è¦æ¸²æŸ“çš„å‡ ä½•å›¾å½¢

```
private Triangle mTriangle;
    private Square   mSquare;
    public void onSurfaceCreated(GL10 unused, EGLConfig config) {
        // è®¾ç½®èƒŒæ™¯é¢œè‰²
        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        // åˆå§‹åŒ–triangle
        mTriangle = new Triangle();
        // åˆå§‹åŒ– square
        mSquare = new Square();
    }
```

äºŒ.ï¼šç»˜åˆ¶å›¾å½¢ï¼Œå› ä¸ºéœ€è¦æä¾›å¾ˆå¤šç»†èŠ‚çš„å›¾å½¢æ¸²æŸ“ç®¡çº¿ï¼Œæ‰€ä»¥ç»˜åˆ¶å›¾å½¢å‰è‡³å°‘éœ€è¦ä¸€ä¸ªé¡¶ç‚¹ç€è‰²å™¨æ¥ç»˜åˆ¶å½¢çŠ¶å’Œä¸€ä¸ªç‰‡æ®µç€è‰²å™¨çš„é¢œè‰²ï¼Œå½¢çŠ¶ã€‚è¿™äº›ç€è‰²å™¨å¿…é¡»è¢«ç¼–è¯‘ï¼Œç„¶ååŠ å…¥åˆ°ä¸€ä¸ªOpenGL ESç¨‹åºï¼Œç„¶åå°†å…¶ç”¨äºç»˜åˆ¶å½¢çŠ¶ã€‚ç®€å•ä»‹ç»ä¸‹è¿™å‡ ä¸ªæ¦‚å¿µï¼š - é¡¶ç‚¹ç€è‰²å™¨ï¼ˆVertex Shaderï¼‰é¡¶ç‚¹ç€è‰²å™¨æ˜¯GPUä¸Šè¿è¡Œçš„å°ç¨‹åºï¼Œç”±åå­—å¯ä»¥çŸ¥é“ï¼Œé€šè¿‡å®ƒæ¥å¤„ç†é¡¶ç‚¹ï¼Œä»–ç”¨äºæ¸²æŸ“å›¾å½¢é¡¶ç‚¹çš„OpenGL ESå›¾å½¢ä»£ç ã€‚é¡¶ç‚¹ç€è‰²å™¨å¯ç”¨æ¥ä¿®æ”¹å›¾å½¢çš„ä½ç½®ï¼Œé¢œè‰²ï¼Œçº¹ç†åæ ‡ï¼Œä¸è¿‡ä¸èƒ½ç”¨æ¥åˆ›å»ºæ–°çš„é¡¶ç‚¹åæ ‡ã€‚ - ç‰‡æ®µç€è‰²å™¨ï¼ˆFragment Shader ) ç”¨äºå‘ˆç°ä¸é¢œè‰²æˆ–çº¹ç†çš„å½¢çŠ¶çš„é¢çš„OpenGL ESä»£ç ã€‚ - é¡¹ç›®ï¼ˆProgramï¼‰ -åŒ…å«è¦ç”¨äºç»˜åˆ¶ä¸€ä¸ªæˆ–å¤šä¸ªå½¢çŠ¶ç€è‰²å™¨çš„OpenGL ESçš„å¯¹è±¡ã€‚

ä¸‹é¢ç»™Triangleç±»å®šä¹‰ä¸€ä¸ªåŸºæœ¬çš„ç€è‰²å™¨ä»£ç ï¼š

```
public class Triangle {

    private final String vertexShaderCode =
        "attribute vec4 vPosition;" +
        "void main() {" +
        "  gl_Position = vPosition;" +
        "}";

    private final String fragmentShaderCode =
        "precision mediump float;" +
        "uniform vec4 vColor;" +
        "void main() {" +
        "  gl_FragColor = vColor;" +
        "}";

    ...
}
```

å½“ç„¶ï¼Œä¸Šé¢æˆ‘ä»¬åˆ›å»ºäº†ç€è‰²å™¨çš„ç¼–è¯‘ä»£ç ï¼Œä»£ç ç¼–å†™å®Œæˆï¼Œéœ€è¦å†™ä¸ªæ–¹æ³•æ¥æ‰§è¡Œè¿™æ®µä»£ç ï¼Œè¿™é‡Œæˆ‘ä»¬åœ¨æ¸²æŸ“å™¨ä¸­å†™ä¸€ä¸ªå¦‚ä¸‹æ–¹æ³•æ¥æ‰§è¡Œç€è‰²å™¨ä»£ç ï¼š

```
public static int loadShader(int type, String shaderCode){

        // åˆ›é€ é¡¶ç‚¹ç€è‰²å™¨ç±»å‹(GLES20.GL_VERTEX_SHADER)
        // æˆ–è€…æ˜¯ç‰‡æ®µç€è‰²å™¨ç±»å‹ (GLES20.GL_FRAGMENT_SHADER)
        int shader = GLES20.glCreateShader(type);
        // æ·»åŠ ä¸Šé¢ç¼–å†™çš„ç€è‰²å™¨ä»£ç å¹¶ç¼–è¯‘å®ƒ
        GLES20.glShaderSource(shader, shaderCode);
        GLES20.glCompileShader(shader);
        return shader;
    }
```

> è¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œå› ä¸ºç€è‰²å™¨çš„ä»£ç æ‰§è¡Œæ˜¯å¾ˆæ˜‚è´µæ»´ï¼Œæ‰€ä»¥é¿å…å¤šæ¬¡æ‰§è¡Œï¼Œéœ€è¦æˆ‘ä»¬ä¸€èˆ¬å°†æ‰§è¡Œä»£ç çš„é€»è¾‘å†™å¸¦å›¾å½¢ç±»çš„æ„é€ æ–¹æ³•ä¸­ã€‚æ¯”å¦‚ä¸Šé¢çš„Triangleï¼Œæˆ‘ä»¬å°±è¿™ä¹ˆå†™ï¼š

```
private final int mProgram;
public Triangle() {
        ... ...//æ•°æ®è½¬æ¢
        int vertexShader = OneGlRenderer.loadShader(GLES20.GL_VERTEX_SHADER,
                vertexShaderCode);
        int fragmentShader = OneGlRenderer.loadShader(GLES20.GL_FRAGMENT_SHADER,
                fragmentShaderCode);

        // åˆ›å»ºç©ºçš„OpenGL ESç¨‹åº
        mProgram = GLES20.glCreateProgram();

        // æ·»åŠ é¡¶ç‚¹ç€è‰²å™¨åˆ°ç¨‹åºä¸­
        GLES20.glAttachShader(mProgram, vertexShader);

        // æ·»åŠ ç‰‡æ®µç€è‰²å™¨åˆ°ç¨‹åºä¸­
        GLES20.glAttachShader(mProgram, fragmentShader);

        // åˆ›å»ºOpenGL ESç¨‹åºå¯æ‰§è¡Œæ–‡ä»¶
        GLES20.glLinkProgram(mProgram);
    }
```

æœ€åï¼Œæ‰€æœ‰ç»˜åˆ¶çš„æ‰€æœ‰åŸºæœ¬é…ç½®éƒ½é…ç½®å®Œæˆä¹‹åï¼Œæˆ‘ä»¬æ¥å†™ç»˜åˆ¶å›¾å½¢çš„æ–¹æ³•ï¼Œæˆ‘ä»¬åœ¨å›¾å½¢ç±»ï¼ˆTriangleï¼‰ä¸­åˆ›å»ºä¸€ä¸ªç»˜åˆ¶çš„æ–¹æ³•onDraw(),å¯ä»¥åœ¨onDraw()æ–¹æ³•ä¸­è®¾ç½®ç»˜åˆ¶é€»è¾‘ã€‚

```
private int mPositionHandle;
    private int mColorHandle;

    private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;
    private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex

    public void draw() {
        // å°†ç¨‹åºæ·»åŠ åˆ°OpenGL ESç¯å¢ƒ
        GLES20.glUseProgram(mProgram);

        // è·å–é¡¶ç‚¹ç€è‰²å™¨çš„ä½ç½®çš„å¥æŸ„
        mPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");

        // å¯ç”¨ä¸‰è§’å½¢é¡¶ç‚¹ä½ç½®çš„å¥æŸ„
        GLES20.glEnableVertexAttribArray(mPositionHandle);

        //å‡†å¤‡ä¸‰è§’å½¢åæ ‡æ•°æ®
        GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX,
                GLES20.GL_FLOAT, false,
                vertexStride, vertexBuffer);

        // è·å–ç‰‡æ®µç€è‰²å™¨çš„é¢œè‰²çš„å¥æŸ„
        mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor");

        // è®¾ç½®ç»˜åˆ¶ä¸‰è§’å½¢çš„é¢œè‰²
        GLES20.glUniform4fv(mColorHandle, 1, color, 0);

        // ç»˜åˆ¶ä¸‰è§’å½¢
        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

        // ç¦ç”¨é¡¶ç‚¹æ•°ç»„
        GLES20.glDisableVertexAttribArray(mPositionHandle);
    }
```

å®Œæˆä¸Šé¢æ‰€æœ‰æ­¥éª¤ï¼Œåªéœ€è¦åœ¨GlSurfaceView.Rendererçš„onDrawFrame()æ–¹æ³•ä¸­è°ƒç”¨å›¾å½¢ç±»çš„ç»˜åˆ¶æ–¹æ³•å³å¯ï¼ˆä¸Šé¢çš„onDraw()ï¼‰:

```
public void onDrawFrame(GL10 unused) {
        mTriangle.draw();
    }
```

æœ€åçš„å‘ˆç°æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb5a9b4c4da4c008c9ede789d3f7219~tplv-k3u1fbpfcp-zoom-1.image)


## è¿ç”¨æŠ•å½±å’Œç›¸æœºè§†å›¾

é€šå¸¸æƒ…å†µä¸‹ï¼ŒOpenGlä¸­å±•ç¤ºçš„è§†å›¾å’Œåœ¨Androidä¸Šæ˜¾ç¤ºçš„å›¾å½¢ä¼šæœ‰åå·®ã€‚å€Ÿç”¨å®˜æ–¹å›¾ç‰‡ï¼š


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34c1f6879c4f4dc390edb3de13b8ab6a~tplv-k3u1fbpfcp-zoom-1.image)


å½“ç„¶æˆ‘ä»¬å¯ä»¥é€šè¿‡çŸ©é˜µè½¬æ¢æ¥è§£å†³è¿™ç§é—®é¢˜ï¼Œè®©OpenGlä¸Šçš„è§†å›¾åœ¨ä»»ä½•androidè®¾å¤‡ä¸Šæ˜¾ç¤ºçš„æ¯”ä¾‹éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè¿™é‡Œè¯´ä¸‹ä»€ä¹ˆæ˜¯æŠ•å½±å’Œç›¸æœºè§†å›¾ï¼š

## æŠ•å½±çš„å®šä¹‰

ä½¿ç”¨OpenGlç»˜åˆ¶çš„3Då›¾å½¢ï¼Œéœ€è¦å±•ç¤ºåœ¨ç§»åŠ¨ç«¯2Dè®¾å¤‡ä¸Šï¼Œè¿™å°±æ˜¯æŠ•å½±ã€‚Android OpenGl ESä¸­æœ‰ä¸¤ç§æŠ•å½±æ–¹å¼ï¼šä¸€ç§æ˜¯æ­£äº¤æŠ•å½±ï¼Œä¸€ç§æ˜¯é€è§†æŠ•å½±ï¼š

æ­£äº¤æŠ•å½±æŠ•å½±ç‰©ä½“çš„å¸¦ä¸‹ä¸ä¼šéšè§‚å¯Ÿç‚¹çš„è¿œè¿‘è€Œå‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹é¢æ–¹æ³•æ¥æ‰§è¡Œæ­£äº¤æŠ•å½±ï¼š

```
Matrix.orthoM (float[] m,           //æ¥æ”¶æ­£äº¤æŠ•å½±çš„å˜æ¢çŸ©é˜µ
                int mOffset,        //å˜æ¢çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
                float left,         //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„å·¦è¾¹è·
                float right,        //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„å³è¾¹è·
                float bottom,       //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„ä¸‹è¾¹è·
                float top,          //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„ä¸Šè¾¹è·
                float near,         //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢è·ç¦»
                float far)          //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿œé¢è·ç¦»
```

é€è§†æŠ•å½±ï¼šéšè§‚å¯Ÿç‚¹çš„è·ç¦»å˜åŒ–è€Œå˜åŒ–ï¼Œè§‚å¯Ÿç‚¹è¶Šè¿œï¼Œè§†å›¾è¶Šå°ï¼Œåä¹‹è¶Šå¤§ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¦‚ä¸‹æ–¹æ³•æ¥è®¾ç½®é€è§†æŠ•å½±ï¼š

```
Matrix.frustumM (float[] m,         //æ¥æ”¶é€è§†æŠ•å½±çš„å˜æ¢çŸ©é˜µ
                int mOffset,        //å˜æ¢çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
                float left,         //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„å·¦è¾¹è·
                float right,        //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„å³è¾¹è·
                float bottom,       //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„ä¸‹è¾¹è·
                float top,          //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢çš„ä¸Šè¾¹è·
                float near,         //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿‘é¢è·ç¦»
                float far)          //ç›¸å¯¹è§‚å¯Ÿç‚¹è¿œé¢è·ç¦»
```

## ç›¸æœºè§†å›¾

ä»€ä¹ˆæ˜¯ç›¸æœºè§†å›¾ï¼Ÿç®€å•æ¥è¯´ç”Ÿæ´»ä¸­æˆ‘ä»¬æ‹ç…§ï¼Œä½ ç«™çš„é«˜åº¦ï¼Œæ‹¿ç›¸æœºçš„ä½ç½®ï¼Œå§¿åŠ¿ä¸åŒï¼Œæ‹å‡ºæ¥çš„ç…§ç‰‡ä¹Ÿå°±ä¸ä¸€æ ·ï¼Œç›¸æœºè§†å›¾å°±æ˜¯æ¥ä¿®æ”¹ç›¸æœºä½ç½®ï¼Œè§‚å¯Ÿæ–¹å¼ä»¥åŠç›¸æœºçš„å€¾æ–œè§’åº¦ç­‰å±æ€§ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹é¢æ–¹æ³•æ¥ä¿®æ”¹ç›¸æœºè§†å›¾å±æ€§ï¼š

```
Matrix.setLookAtM (float[] rm,      //æ¥æ”¶ç›¸æœºå˜æ¢çŸ©é˜µ
                int rmOffset,       //å˜æ¢çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
                float eyeX,float eyeY, float eyeZ,   //ç›¸æœºä½ç½®
                float centerX,float centerY,float centerZ,  //è§‚å¯Ÿç‚¹ä½ç½®
                float upX,float upY,float upZ)  //upå‘é‡åœ¨xyzä¸Šçš„åˆ†é‡
```

## è½¬æ¢çŸ©é˜µï¼ˆå˜æ¢çŸ©é˜µï¼‰

è½¬æ¢çŸ©é˜µç”¨æ¥åšä»€ä¹ˆçš„å‘¢ï¼Ÿæ˜¯å¦è®°å¾—ä¸Šé¢æˆ‘ä»¬ç»˜åˆ¶çš„å›¾å½¢åæ ‡éœ€è¦è½¬æ¢ä¸ºOpenGlä¸­èƒ½å¤„ç†çš„å°ç«¯å­—èŠ‚åºï¼ˆLittleEdianï¼‰ï¼Œæ²¡é”™ï¼Œè½¬æ¢çŸ©é˜µå°±æ˜¯ç”¨æ¥å°†æ•°æ®è½¬ä¸ºOpenGl ESå¯ç”¨çš„æ•°æ®å­—èŠ‚ï¼Œæˆ‘ä»¬å°†ç›¸æœºè§†å›¾å’ŒæŠ•å½±è®¾ç½®çš„æ•°æ®ç›¸ä¹˜ï¼Œä¾¿å¾—åˆ°ä¸€ä¸ªè½¬æ¢çŸ©é˜µï¼Œç„¶åæˆ‘ä»¬å†è®²æ­¤çŸ©é˜µä¼ ç»™é¡¶ç‚¹ç€è‰²å™¨ï¼Œå…·ä½“ä½¿ç”¨æ–¹æ³•åŠå‚æ•°è¯´æ˜å¦‚ä¸‹ï¼š

```
Matrix.multiplyMM (float[] result, //æ¥æ”¶ç›¸ä¹˜ç»“æœ
                int resultOffset,  //æ¥æ”¶çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
                float[] lhs,       //å·¦çŸ©é˜µ
                int lhsOffset,     //å·¦çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
                float[] rhs,       //å³çŸ©é˜µ
                int rhsOffset)     //å³çŸ©é˜µçš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
```

ä¸‹é¢ç®€å•è®²è§£ä¸‹å¦‚ä½•ä½¿ç”¨æŠ•å½±å’Œç›¸æœºè§†å›¾æ¥å®ç°çŸ©é˜µå˜æ¢å¹¶ä¼ é€’ç»™é¡¶ç‚¹ç€è‰²å™¨ï¼›


1.  å®šä¹‰ä¸€ä¸ªæŠ•å½±ï¼š

```
// mMVPMatrix is an abbreviation for "Model View Projection Matrix"
    private final float[] mMVPMatrix = new float[16];
    private final float[] mProjectionMatrix = new float[16];
    private final float[] mViewMatrix = new float[16];
    public void onSurfaceChanged(GL10 unused, int width, int height) {
        GLES20.glViewport(0, 0, width, height);

        float ratio = (float) width / height;

        // è¿™ä¸ªæŠ•å½±çŸ©é˜µè¢«åº”ç”¨äºå¯¹è±¡åæ ‡åœ¨onDrawFrameï¼ˆï¼‰æ–¹æ³•ä¸­
        Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
    }
```


1.  å®šä¹‰ä¸€ä¸ªç›¸æœºè§†å›¾

```
@Override
public void onDrawFrame(GL10 unused) {
    ...
    // Set the camera position (View matrix)
    Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);

    // Calculate the projection and view transformation
    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);

    // Draw shape
    mTriangle.draw(mMVPMatrix);
}
```

1.  ä¿®æ”¹å›¾å½¢ç±»æ‰§è¡Œä»£ç 

```
public class Triangle {

    private final String vertexShaderCode =
        // This matrix member variable provides a hook to manipulate
        // the coordinates of the objects that use this vertex shader
        "uniform mat4 uMVPMatrix;" +
        "attribute vec4 vPosition;" +
        "void main() {" +
        // the matrix must be included as a modifier of gl_Position
        // Note that the uMVPMatrix factor *must be first* in order
        // for the matrix multiplication product to be correct.
        "  gl_Position = uMVPMatrix * vPosition;" +
        "}";

    // Use to access and set the view transformation
    private int mMVPMatrixHandle;

    ...
}
```


1.  æŠ•å½±å’Œç›¸æœºè§†å›¾ä»£ç åˆ°å›¾å½¢ç±»çš„ç»˜åˆ¶æ–¹æ³•ä¸­å»onDraw()

```
public void draw(float[] mvpMatrix){
       ... ...
        // å¾—åˆ°å½¢çŠ¶çš„å˜æ¢çŸ©é˜µçš„å¥æŸ„
        mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");

        // å°†æŠ•å½±å’Œè§†å›¾è½¬æ¢ä¼ é€’ç»™ç€è‰²å™¨
        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);

        // ç”»ä¸‰è§’å½¢
        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

        // ç¦ç”¨é¡¶ç‚¹æ•°ç»„
        GLES20.glDisableVertexAttribArray(mPositionHandle);
    }
```

åšå®Œè¿™äº›ï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°å¦‚ä¸‹å›¾ï¼š


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63fab1b586b4221b822bfc5de201308~tplv-k3u1fbpfcp-zoom-1.image)


æ²¡é”™ï¼Œè¿™æ‰æ²¡æœ‰å˜å½¢çš„è§†å›¾ã€‚åˆ°è¿™é‡Œï¼ŒåŸºæœ¬çš„é€šè¿‡OpenGlç»˜åˆ¶ç®€å•å›¾å½¢å°±overäº†ï¼Œä¸‹é¢æˆ‘ä»¬è®²è§£ä¸‹å¦‚ä½•æ·»åŠ ä¸€äº›äº¤äº’åŠ¨ä½œã€‚

## æ·»åŠ åŠ¨ä½œ

å‰é¢éƒ½æ˜¯ç®€å•çš„åŠ¨ä½œä»‹ç»ï¼Œä½¿ç”¨OpenGlåœ¨å±å¹•ä¸Šç»˜åˆ¶å¯¹è±¡æ˜¯ä½¿ç”¨openGlçš„åŸºæœ¬åŠŸã€‚ä¸‹é¢æˆ‘æ¥è¯´ä¸‹å¦‚ä½•æ·»åŠ æ—‹è½¬å½¢çŠ¶ã€‚ä½¿ç”¨OpenGlçš„æç»˜å¯¹è±¡æ˜¯ç›¸å¯¹ç®€å•çš„ï¼Œé¦–å…ˆéœ€è¦åœ¨æ¸²æŸ“å™¨ä¸­åˆ›å»ºä¸€ç»„æ—‹è½¬çŸ©é˜µï¼Œç„¶åä½¿ç”¨ä¹‹å‰æåˆ°è¿‡çš„æŠ•å½±å’Œç›¸æœºè§†å›¾å˜æ¢çŸ©é˜µç»“åˆèµ·æ¥ä½¿ç”¨ï¼š

```
private float[] mRotationMatrix = new float[16];
public void onDrawFrame(GL10 gl) {
    float[] scratch = new float[16];

    ...

    // åˆ›å»ºä¸€ä¸ªæ—‹è½¬çŸ©é˜µ
    long time = SystemClock.uptimeMillis() % 4000L;
    float angle = 0.090f * ((int) time);
    Matrix.setRotateM(mRotationMatrix, 0, angle, 0, 0, -1.0f);

    // å°†æ—‹è½¬çŸ©é˜µä¸æŠ•å½±å’Œç›¸æœºè§†å›¾ç»„åˆåœ¨ä¸€èµ·
    // Note that the mMVPMatrix factor *must be first* in order
    // for the matrix multiplication product to be correct.
    Matrix.multiplyMM(scratch, 0, mMVPMatrix, 0, mRotationMatrix, 0);

    // Draw triangle
    mTriangle.draw(scratch);
}
```

è¿è¡Œæ•ˆæœå›¾å¦‚ä¸‹ï¼š


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/528f786afa114fa1829fabbd7b1eb4b4~tplv-k3u1fbpfcp-zoom-1.image)


## ä¿®æ”¹é¡¶ç‚¹é¢œè‰²

ä¸€ä¸ªé¢œè‰²æ˜¯ä¸æ˜¯å¤ªå•è°ƒäº†ï¼Ÿå¦‚ä½•è®©åšæˆå¤šå½©çš„å‘¢ï¼Ÿæ¥ä¸‹æ¥æˆ‘ä»¬æ¥åšä¸€ä¸ªå¤šå½©ä¸‰è§’å½¢ï¼Œå¦‚ä½•æ¥åšä¸€ä¸ªå¤šå½©ä¸‰è§’å½¢ï¼Ÿæˆ‘ä»¬é€šè¿‡é¡¶ç‚¹ç€è‰²å™¨æ¥åšã€‚åŸºäºä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬åªéœ€è¦åšä¸€ç‚¹ç‚¹æ”¹åŠ¨ï¼Œä¸‹é¢æ˜¯åŸºæœ¬æ­¥éª¤ï¼š 1. ä¿®æ”¹ç€è‰²å™¨ä»£ç  2. å°†é¢œè‰²å€¼ä¿®æ”¹ä¸ºfloatæ•°ç»„å¹¶è½¬ä¸ºfloatBuffer 3. å°†è·å–çš„floatBufferä¼ é€’ç»™é¡¶ç‚¹ç€è‰²å™¨ã€‚

ä¿®æ”¹ç€è‰²å™¨ä»£ç ï¼š

```
private final String vertexShaderCode =
            "attribute vec4 vPosition;" +
                    "uniform mat4 uMVPMatrix;"+
                    "varying  vec4 vColor;"+
                    "attribute vec4 aColor;"+
                    "void main() {" +
                    "  gl_Position = uMVPMatrix*vPosition;" +
                    "  vColor=aColor;"+
                    "}";

    private final String fragmentShaderCode =
            "precision mediump float;" +
                    "varying vec4 vColor;" +
                    "void main() {" +
                    "  gl_FragColor = vColor;" +
                    "}";
```

## shaderçš„å˜é‡ç±»å‹(uniformï¼Œattributeå’Œvarying)çš„åŒºåˆ«

å…³äºshaderçš„å˜é‡ç±»å‹(uniformï¼Œattributeå’Œvarying)çš„åŒºåˆ«åŠä½¿ç”¨ï¼Œä¸‹é¢åšä¸‹è¯´æ˜ï¼š 
1. uniform:uniformå˜é‡åœ¨vertexå’Œfragmentä¸¤è€…ä¹‹é—´å£°æ˜æ–¹å¼å®Œå…¨ä¸€æ ·ï¼Œåˆ™å®ƒå¯ä»¥åœ¨vertexå’Œfragmentå…±äº«ä½¿ç”¨ã€‚ï¼ˆç›¸å½“äºä¸€ä¸ªè¢«vertexå’Œfragment shaderå…±äº«çš„å…¨å±€å˜é‡ï¼‰uniformå˜é‡ä¸€èˆ¬ç”¨æ¥è¡¨ç¤ºï¼šå˜æ¢çŸ©é˜µï¼Œæè´¨ï¼Œå…‰ç…§å‚æ•°å’Œé¢œè‰²ç­‰ä¿¡æ¯ã€‚åœ¨ä»£ç ä¸­é€šè¿‡GLES20.glGetUniformLocation(int program, String name)æ¥è·å–å±æ€§å€¼ã€‚å¹¶é€šè¿‡ GLES20.glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int offset);æ–¹æ³•å°†æ•°æ®ä¼ é€’ç»™ç€è‰²å™¨ã€‚ 
2. attribute:è¿™ä¸ªå˜é‡åªèƒ½åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ä½¿ç”¨(vertex Shader),ç”¨æ¥è¡¨ç¤ºé¡¶ç‚¹çš„æ•°æ®ï¼Œæ¯”å¦‚é¡¶ç‚¹åæ ‡ï¼Œé¡¶ç‚¹é¢œè‰²ï¼Œæ³•çº¿ï¼Œçº¹ç†åæ ‡ç­‰ã€‚åœ¨ç»˜åˆ¶çš„æ—¶å€™é€šè¿‡GLES20.glGetAttribLocationï¼ˆint program, String nameï¼‰æ¥è·å–å˜é‡å€¼ï¼Œé€šè¿‡ GLES20.glEnableVertexAttribArray(int index)æ¥å¯åŠ¨å¥æŸ„ï¼Œæœ€åé€šè¿‡ GLES20.glVertexAttribPointer(int indx,int size,int type,boolean normalized,int stride,java.nio.Buffer ptr)æ¥è®¾ç½®å›¾å½¢æ•°æ®ã€‚ 
3. varyingå˜é‡ï¼šè¿™ä¸ªå˜é‡åªèƒ½ç”¨æ¥åœ¨vertexå’Œfragment shaderä¹‹é—´ä¼ é€’æ•°æ®æ—¶ä½¿ç”¨ï¼Œä¸å¯ä»¥é€šè¿‡ä»£ç è·å–å…¶å˜é‡å€¼ã€‚

æ¥æ¥ä¸‹æˆ‘ä»¬è¿›è¡Œæ•°æ®è½¬æ¢ï¼š

```
float color[] = {
            1.0f, 0f, 0f, 1.0f ,
            0f, 1.0f, 0f, 1.0f ,
            0f, 0f, 1.0f, 1.0f
    };
        public Triangle() {
           ... ...
          ByteBuffer dd = ByteBuffer.allocateDirect(
                    color.length * 4);
            dd.order(ByteOrder.nativeOrder());
            colorBuffer = dd.asFloatBuffer();
            colorBuffer.put(color);
            colorBuffer.position(0);
        }
```

æœ€åæˆ‘ä»¬éœ€è¦è·å–ç€è‰²å™¨çš„å¥æŸ„å¹¶è®¾ç½®ç€è‰²å™¨çš„é¢œè‰²ï¼š

```
public void draw(float[] mvpMatrix){
        ... ... 
         /* // è·å–ç‰‡æ®µç€è‰²å™¨çš„vColoræˆå‘˜çš„å¥æŸ„
        mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor");

        // è®¾ç½®ç»˜åˆ¶ä¸‰è§’å½¢çš„é¢œè‰²
        GLES20.glUniform4fv(mColorHandle, 1, colorBuffer, 0);*/

        //è·å–ç‰‡å…ƒç€è‰²å™¨çš„vColoræˆå‘˜çš„å¥æŸ„
        mColorHandle = GLES20.glGetAttribLocation(mProgram, "aColor");
        //è®¾ç½®ç»˜åˆ¶ä¸‰è§’å½¢çš„é¢œè‰²
        GLES20.glEnableVertexAttribArray(mColorHandle);
        GLES20.glVertexAttribPointer(mColorHandle,4,
                GLES20.GL_FLOAT,false,
                0,colorBuffer);
                ... ...
                }
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3177eb6d484e4d14afdc9eef78d7408a~tplv-k3u1fbpfcp-zoom-1.image)



## 6. å‚è€ƒé“¾æ¥ï¼š

1.  [openglå®˜ç½‘](https://developer.android.com/guide/topics/graphics/opengl.html)
1.  [openglçš„ç¯å¢ƒæ­å»ºåŠåŸºæœ¬æ•™ç¨‹](https://developer.android.com/training/graphics/opengl/environment.html)

## 7. é¡¹ç›®åœ°å€ï¼š

- [AserbaoAndroid](https://github.com/aserbao/AserbaosAndroid)æ­¤é¡¹ç›®ä¸ºåšä¸»æ‰€æœ‰çš„ç³»åˆ—å­¦ä¹ çš„ä»£ç æ±‡æ€»é¡¹ç›®ï¼Œè¯¥æ–‡ç« çš„ä»£ç ä½äºï¼šopengl/OneOpenGl/OneOpenGlActivity
- å¦‚æœå¯¹éŸ³è§†é¢‘å¼€å‘æœ‰å…´è¶£çš„åŒå­¦å¯ä»¥çœ‹çœ‹è¿™ä¸ªé¡¹ç›®ï¼š[AndroidCamera](https://github.com/aserbao/AndroidCamera) è¿™ä¸ªé¡¹ç›®åŠŸèƒ½åŒ…æ‹¬è§†é¢‘äººè„¸è¯†åˆ«è´´çº¸ï¼Œç¾é¢œï¼Œåˆ†æ®µå½•åˆ¶ï¼Œè§†é¢‘è£å‰ªï¼Œè§†é¢‘å¸§å¤„ç†ï¼Œè·å–è§†é¢‘å…³é”®å¸§ï¼Œè§†é¢‘æ—‹è½¬ï¼Œæ·»åŠ æ»¤é•œï¼Œæ·»åŠ æ°´å°ã€‚





æˆ‘æ­£åœ¨å‚ä¸æ˜é‡‘æŠ€æœ¯ç¤¾åŒºåˆ›ä½œè€…ç­¾çº¦è®¡åˆ’æ‹›å‹Ÿæ´»åŠ¨ï¼Œ[ç‚¹å‡»é“¾æ¥æŠ¥åæŠ•ç¨¿](https://juejin.cn/post/7112770927082864653 "https://juejin.cn/post/7112770927082864653")ã€‚