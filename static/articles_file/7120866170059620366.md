
å…¶å®iOSé¢†åŸŸå¾ˆå¤šæ–‡ç« éƒ½è°ˆåˆ°äº†å…³äºé”çš„æ–‡ç« ï¼Œä½†æ˜¯æˆ‘ä¸ºä»€ä¹ˆè¦åœ¨è¿™é‡Œé‡æ–°å†™ä¸€ç¯‡æ–‡ç« å‘¢ï¼Ÿä¸€æ˜¯å¾ˆå¤šæ–‡ç« ä½¿ç”¨çš„è§‚ç‚¹ä¾ç„¶æ˜¯å¾ˆè€çš„è§‚ç‚¹ï¼Œå’Œæˆ‘çš„æµ‹è¯•ç»“æœä¸ç¬¦åˆï¼ŒäºŒåˆ™æ˜¯è‡ªå·±å¯¹è¿™æ–¹é¢ä¹Ÿæ¯”è¾ƒç”Ÿç–ï¼Œæ‰€ä»¥å°±åœ¨æœ€è¿‘é‡æ–°æ¢³ç†ä¸€ä¸‹è‡ªå·±å¯¹ç€æ–¹é¢çš„è°ƒæŸ¥ï¼Œæ¢³ç†ä¸€ä¸‹è¿™ä¸€å—çš„çŸ¥è¯†ç‚¹ã€‚

é¦–å…ˆæ˜¯ä¸€æ³¢å¯¹æ¯”ï¼Œæˆ‘ä½¿ç”¨äº†**10^7**æ¬¡éå†ï¼Œä½¿ç”¨çš„å¼€å‘è¯­è¨€æ˜¯Swiftï¼Œåœ¨iOS15.5ç³»ç»Ÿç‰ˆæœ¬çš„iPhone13çœŸæœºä¸Šè·‘å‡ºçš„æ•°æ®ï¼š


![iOSä¸­ä¸åŒé”çš„æ€§èƒ½å¯¹æ¯”.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaeb5e17ac6a4aa6a8b29550c7f0f324~tplv-k3u1fbpfcp-watermark.image?)

æ•´ä½“æ¥è¯´**NSConditionLock**çš„æ€§èƒ½ä¼šç•¥æ…¢ï¼Œä½†æ˜¯å…¶ä»–çš„æ€§èƒ½éƒ½ç±»ä¼¼ï¼Œåœ¨è¿™ä¸ªé‡çº§çš„æ•°æ®å¤„ç†ä¸‹ï¼Œå®ƒä»¬çš„è¡¨ç°éƒ½éå¸¸çš„æ¥è¿‘ã€‚ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºæ€§èƒ½æœ€å¥½çš„ä¸‰ä¸ªé”æ˜¯**os_unfair_lock**ã€**pthread_mutex**ä»¥åŠ**DispatchSemaphore**ï¼Œå‰ä¸¤è€…æ˜¯äº’æ–¥é”ï¼Œåè€…æ˜¯ä¿¡å·é‡ã€‚

é¦–å…ˆæˆ‘æƒ³æå‡ºä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯é”çš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨èŠé”çš„ç›®çš„ä¹‹å‰ï¼Œé‚£é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªæ¦‚å¿µï¼Œé‚£å°±æ˜¯**çº¿ç¨‹å®‰å…¨ã€‚**ä»€ä¹ˆæ˜¯çº¿ç¨‹å®‰å…¨ï¼Ÿ**æˆ‘çš„å®šä¹‰æ˜¯å½“å¤šçº¿ç¨‹éƒ½éœ€è¦æ“ä½œæŸä¸ªå…±äº«æ•°æ®æ—¶ï¼Œå¹¶ä¸ä¼šå¼•èµ·æ„æ–™ä¹‹å¤–çš„æƒ…å†µï¼Œèƒ½ä¿è¯è¯¥å…±äº«æ•°æ®çš„æ­£ç¡®æ€§ã€‚**å¯æ˜¯å¦‚ä½•å»å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨ç±»å‘¢ï¼Ÿé€šç”¨çš„æ–¹å¼å°±æ˜¯åœ¨ä¸€äº›æ•°æ®çš„æ“ä½œä¸ŠåŠ é”ã€‚**è€Œé”çš„ç›®çš„å°±æ˜¯ç¡®ä¿å¤šçº¿ç¨‹æ“ä½œå…±äº«æ•°æ®æ—¶ï¼Œèƒ½ä¿è¯æ•°æ®çš„å‡†ç¡®æ€§å’Œå¯é¢„æµ‹æ€§ã€‚**

## os_unfair_lock

æˆ‘ç›¸ä¿¡æœ‰å¾ˆå¤šäººéƒ½é˜…è¯»è¿‡ibiremeå…³äºé”çš„æ€§èƒ½å¯¹æ¯”çš„çŸ¥åæ–‡ç« [ã€Šä¸å†å®‰å…¨çš„ OSSpinLockã€‹](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)ï¼Œå…¶ä¸­æåˆ°äº†OSSpinLockä¸å†å®‰å…¨çš„ç†ç”±ï¼Œä½†æ˜¯ç”±æ­¤å´å¼•å‘ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯OSSpinLockä¸»è¦çš„ä½¿ç”¨åœºæ™¯æ˜¯å“ªé‡Œå‘¢ï¼Ÿ

æˆ‘ä»¬éƒ½çŸ¥é“åœ¨Objective-Cä¸­å®šä¹‰ä¸€ä¸ªå±æ€§çš„æ—¶å€™ï¼Œæœ‰æ—¶å±æ€§ä¼šè¢«å£°æ˜ä¸º**atomicï¼Œ**è¿™å°±æ˜¯è¯´è¿™ä¸ªå±æ€§çš„setæ“ä½œå’Œgetæ“ä½œæ˜¯åŸå­æ€§çš„ï¼Œé‚£ä¹ˆå¦‚ä½•ç¡®ä¿è¿™äº› æ“ä½œçš„åŸå­æ€§å‘¢ï¼Ÿæˆ‘æƒ³è¿™ä¸ªæ—¶å€™ä½ å·²ç»çŒœåˆ°ç­”æ¡ˆäº†ï¼ŒAppleä½¿ç”¨çš„æ–¹æ¡ˆæ˜¯**OSSpinLock**ï¼Œè¿™æ˜¯ä¸€ä¸ªè‡ªæ—‹é”ï¼Œä½†æ˜¯è¿™ä¸ªé”æœ‰ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œé‚£å°±æ˜¯ä¼˜å…ˆçº§åè½¬é—®é¢˜ä¼šå¯¼è‡´è‡ªæ—‹é”å‘ç”Ÿæ­»é”ã€‚

> iOS ç³»ç»Ÿä¸­ç»´æŠ¤äº† 5 ä¸ªä¸åŒçš„çº¿ç¨‹ä¼˜å…ˆçº§/QoS: backgroundï¼Œutilityï¼Œdefaultï¼Œuser-initiatedï¼Œuser-interactiveã€‚é«˜ä¼˜å…ˆçº§çº¿ç¨‹å§‹ç»ˆä¼šåœ¨ä½ä¼˜å…ˆçº§çº¿ç¨‹å‰æ‰§è¡Œï¼Œä¸€ä¸ªçº¿ç¨‹ä¸ä¼šå—åˆ°æ¯”å®ƒæ›´ä½ä¼˜å…ˆçº§çº¿ç¨‹çš„å¹²æ‰°ã€‚è¿™ç§çº¿ç¨‹è°ƒåº¦ç®—æ³•ä¼šäº§ç”Ÿæ½œåœ¨çš„ä¼˜å…ˆçº§åè½¬é—®é¢˜ï¼Œä»è€Œç ´åäº† spin lockã€‚

å…·ä½“æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªä½ä¼˜å…ˆçº§çš„çº¿ç¨‹è·å¾—é”å¹¶è®¿é—®å…±äº«èµ„æºï¼Œè¿™æ—¶ä¸€ä¸ªé«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹ä¹Ÿå°è¯•è·å¾—è¿™ä¸ªé”ï¼Œå®ƒä¼šå¤„äº spin lock çš„å¿™ç­‰çŠ¶æ€ä»è€Œå ç”¨å¤§é‡ CPUã€‚æ­¤æ—¶ä½ä¼˜å…ˆçº§çº¿ç¨‹æ— æ³•ä¸é«˜ä¼˜å…ˆçº§çº¿ç¨‹äº‰å¤º CPU æ—¶é—´ï¼Œä»è€Œå¯¼è‡´ä»»åŠ¡è¿Ÿè¿Ÿå®Œä¸æˆã€æ— æ³•é‡Šæ”¾ lockã€‚è¿™å¹¶ä¸åªæ˜¯ç†è®ºä¸Šçš„é—®é¢˜ï¼Œlibobjc å·²ç»é‡åˆ°äº†å¾ˆå¤šæ¬¡è¿™ä¸ªé—®é¢˜äº†ï¼Œäºæ˜¯è‹¹æœçš„å·¥ç¨‹å¸ˆåœç”¨äº† OSSpinLockã€‚

è‹¹æœå·¥ç¨‹å¸ˆ Greg Parker æåˆ°ï¼Œå¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ç”¨ truly unbounded backoff ç®—æ³•ï¼Œè¿™èƒ½é¿å… livelock é—®é¢˜ï¼Œä½†å¦‚æœç³»ç»Ÿè´Ÿè½½é«˜æ—¶ï¼Œå®ƒä»æœ‰å¯èƒ½å°†é«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹é˜»å¡æ•°åç§’ä¹‹ä¹…ï¼›å¦ä¸€ç§æ–¹æ¡ˆæ˜¯ä½¿ç”¨ handoff lock ç®—æ³•ï¼Œè¿™ä¹Ÿæ˜¯ libobjc ç›®å‰æ­£åœ¨ä½¿ç”¨çš„ã€‚é”çš„æŒæœ‰è€…ä¼šæŠŠçº¿ç¨‹ ID ä¿å­˜åˆ°é”å†…éƒ¨ï¼Œé”çš„ç­‰å¾…è€…ä¼šä¸´æ—¶è´¡çŒ®å‡ºå®ƒçš„ä¼˜å…ˆçº§æ¥é¿å…ä¼˜å…ˆçº§åè½¬çš„é—®é¢˜ã€‚ç†è®ºä¸Šè¿™ç§æ¨¡å¼ä¼šåœ¨æ¯”è¾ƒå¤æ‚çš„å¤šé”æ¡ä»¶ä¸‹äº§ç”Ÿé—®é¢˜ï¼Œä½†å®è·µä¸Šç›®å‰è¿˜ä¸€åˆ‡éƒ½å¥½ã€‚
> 

è€Œåœ¨iOS 10ä¹‹åï¼ŒAppleä½¿ç”¨äº†**os_unfair_lock**æ¥æ›¿ä»£äº†**OSSpinLock,** è¿™æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„äº’æ–¥é”ï¼Œè€Œä¸æ˜¯è‡ªæ—‹é”ï¼Œå¦‚æœæ˜¯é˜»æ­¢ä¸¤ä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆè¿™ä¸ªé”æ— ç–‘å¯ä»¥å¾ˆå¥½çš„å®Œæˆå·¥ä½œï¼ŒåŒ…æ‹¬ä¸Šè¿°çš„**pthread_mutex_lock** ä»¥åŠä¿¡å·é‡éƒ½å¯ä»¥ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬éœ€è¦é”å…·å¤‡æŸäº›ç‰¹æ€§ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™å°±éœ€è¦å…¶ä»–å¤šç§ç±»çš„é”äº†ã€‚

```swift
// os_unfair_lockçš„ä½¿ç”¨
var unfairLock = os_unfair_lock()
os_unfair_lock_lock(&unfairLock)
os_unfair_lock_unlock(&unfairLock)

// pthreadMutexçš„ä½¿ç”¨
var pthreadMutex = pthread_mutex_t()
pthread_mutex_lock(&pthreadMutex)
pthread_mutex_unlock(&pthreadMutex)
```

è¿™é‡Œå†è¡¥å……è¯´æ˜ä¸€ä¸‹ï¼ŒAppleä½¿ç”¨åœ¨ä¿è¯åŸå­æ€§æ—¶å®é™…ä¼šè°ƒç”¨åˆ°çš„æ–¹æ³•å¦‚ä¸‹ï¼š

```c
static inline void reallySetProperty() {
		...
		if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
			//PropertyLocksæ˜¯ä¸€ä¸ªStripedMap<spinlock_t>ç±»å‹çš„å…¨å±€å˜é‡
	    //è€ŒStripedMapæ˜¯ä¸€ä¸ªç”¨æ•°ç»„æ¥å®ç°çš„hashmapï¼Œkeyæ˜¯æŒ‡é’ˆï¼Œvalueæ˜¯ç±»å‹æ˜¯spinlock_tå¯¹è±¡
	    //è€Œspinlock_tåˆ™æ˜¯mutex_tt<LOCKDEBUG>çš„ç±»ï¼Œè€Œmutex_ttç±»å†…éƒ¨æ˜¯ç”±os_unfair_lock mLockæ¥å®ç°
	    //æ‰€ä»¥ï¼ŒPropertyLocks[slot]ç›®çš„å°±æ˜¯è·å–os_unfair_lockå¯¹è±¡
        spinlock_t& slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }
		...
}
```

å®ƒé€šè¿‡åœ°å€ä»**PropertyLocks**æ•°ç»„ä¸­å–å‡ºäº†**spinlock_t**é”ï¼Œå¯æ˜¯å¦‚ä½•ä½¿ç”¨åœ°å€ä½œä¸ºæ•°ç»„ä¸‹æ ‡å‘¢ï¼Ÿå®ƒä½¿ç”¨äº†ä¸€ä¸ªå¾ˆå·§å¦™çš„hashç®—æ³•ï¼Œæ¥å®ç°æŒ‡é’ˆåˆ°æ•°ç»„ä¸‹æ ‡çš„è½¬åŒ–ï¼š

```c
static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast<uintptr_t>(p);
        // è¿™æ˜¯ä¸€ä¸ªå“ˆå¸Œç®—æ³•ï¼Œå¯ä»¥å°†å¯¹è±¡çš„åœ°å€è½¬åŒ–ä¸ºæ•°ç»„çš„ä¸‹æ ‡
        // ä½¿å¾—æ•°ç»„å…ƒç´ åœ¨0ï½StripeCountä¹‹é—´
        return ((addr >> 4) ^ (addr >> 9)) % StripeCount;
 }
```

å½“ç„¶è¿™ç§æ–¹æ³•ä¹Ÿä¼šå¶å°”å¯¼è‡´å“ˆå¸Œå†²çªï¼Œä¸¤ä¸ªä¸åŒçš„åœ°å€ä¼šå¯¼è‡´è·å–åˆ°åŒä¸€ä¸ªLockï¼Œè¿™æ ·ä¼šé€ æˆèµ„æºé—²ç½®ï¼Œæ²¡æœ‰å……åˆ†åˆ©ç”¨CPUçš„èµ„æºï¼Œä½†æ˜¯ä¸å¦¨ç¢è¿™ä¸ªå“ˆå¸Œç®—æ³•æ•´ä½“ä¸Šæ˜¯é«˜æ•ˆçš„ã€‚

## NSLock

æ—¢ç„¶å·²ç»æœ‰äº†æ€§èƒ½æ¯”è¾ƒé«˜çš„äº’æ–¥é”ï¼Œé‚£ä¸ºä»€ä¹ˆè¿˜éœ€è¦æœ‰å…¶å®ƒè¿™äº›æ‚ä¸ƒæ‚å…«çš„é”å‘¢ï¼Ÿæ¯”å¦‚è¯´æ¥ä¸‹æ¥æˆ‘ä»¬è¦æåˆ°çš„NSLockï¼Œè¿™ä¸ªé”ä¹Ÿæ˜¯ä¸€ä¸ªäº’æ–¥é”ï¼Œè€Œå®ƒæ˜¯åŸºäºpthread_mutex_lockçš„å°è£…ï¼Œè€Œåœ¨åŸæœ‰çš„åŸºç¡€ä¸Šå¢åŠ äº†ä¸€ä¸ªç‰¹æ€§é‚£å°±æ˜¯è¶…æ—¶ï¼æ²¡é”™è¿™å°±æ˜¯æœ‰å…¶ä»–å„ç§é”çš„åŸå› ï¼Œç»™ä¸åŒçš„é”ä¸åŒçš„ç‰¹æ€§ï¼Œä»¥æ»¡è¶³å…·ä½“çš„å¼€å‘åœºæ™¯ï¼ŒNSLockçš„APIå¦‚ä¸‹ï¼š

```swift
open class NSLock : NSObject, NSLocking {
    open func `try`() -> Bool

    open func lock(before limit: Date) -> Bool

    open var name: String?
}
```

åœ¨æŸäº›æ—¶å€™ï¼Œè¶…æ—¶è¿™ä¸ªç‰¹æ€§æ˜¯éå¸¸æœ‰æ•ˆçš„ï¼Œå› ä¸ºåœ¨ä¸€äº›å¯èƒ½å‘ç”Ÿæ­»é”çš„åœºæ™¯ä¸­ï¼Œä½¿ç”¨NSLockå¯ä»¥è®©æˆ‘ä»¬æœ‰ä¸€ä¸ªä¿é™©æœºåˆ¶ï¼Œå³ä½¿å‘ç”Ÿäº†æ­»é”ï¼Œä¹Ÿå¯ä»¥åœ¨ä¸€å®šçš„æ—¶é—´ä¹‹åèµ°å‡ºåŠ é”çŠ¶æ€ï¼Œæ¢å¤åˆ°æ­£å¸¸çš„ç¨‹åºå¤„ç†é€»è¾‘ã€‚ä½†æ˜¯å’Œä»¥ä¸Šçš„äº’æ–¥é”ä¸€æ ·ï¼Œå®ƒéƒ½æ— æ³•åº”å¯¹é€’å½’çš„æƒ…å†µï¼Œé‚£ä½¿ç”¨ä»€ä¹ˆæ¥å¤„ç†é€’å½’é”å‘¢ï¼Ÿ**NSRecursiveLockï¼**

## NSRecursiveLock

ä½¿ç”¨**NSRecursiveLock**å¯ä»¥ä½¿å¾—è¯¥é”è¢«åŒä¸€çº¿ç¨‹å¤šæ¬¡è·å–è€Œä¸ä¼šå¯¼è‡´çº¿ç¨‹æ­»é”ã€‚ä½†æ˜¯æ¯ä¸€æ¬¡lockéƒ½å¯¹åº”ä¸€æ¬¡unlockï¼Œè¿™æ ·unlockç»“æŸä¹‹åï¼Œé”æ‰ä¼šé‡Šæ”¾ã€‚è€Œé¡¾åæ€ä¹‰ï¼Œè¿™ç§ç±»å‹çš„é”è¢«ç”¨äºä¸€ä¸ªé€’å½’æ–¹æ³•å†…éƒ¨æ¥é˜²æ­¢çº¿ç¨‹è¢«é˜»å¡ã€‚

```swift
let rlock = NSRecursiveLock()

class RThread : Thread {
    
    override func main(){
        rlock.lock()
        print("Thread acquired lock")
        callMe()
        rlock.unlock()
        print("Exiting main")
    }
    
    func callMe(){
        rlock.lock()
        print("Thread acquired lock")
        rlock.unlock()
        print("Exiting callMe")
    }
}

var tr = RThread()
tr.start()

// å¤šæ¬¡ç”³è¯·é”ï¼Œå¹¶ä¸ä¼šå¯¼è‡´å´©æºƒï¼Œè¿™å°±æ˜¯é€’å½’é”çš„ä½œç”¨
```

# NSConditionLock


æ¡ä»¶é”æ»¡è¶³`NSLocking` åè®®ï¼Œæ‰€ä»¥åŸºæœ¬çš„NSLockç±»å‹é”çš„åŸºæœ¬lockï¼Œunlockè¿™ç§å…¨å±€çš„é”æ–¹æ³•å®ƒä¹Ÿæ˜¯å…·å¤‡çš„ï¼Œåˆæ¬¡ä¹‹å¤–ï¼Œå®ƒè¿˜å…·å¤‡è‡ªå·±çš„ç‰¹æ€§ï¼Œé€šå¸¸æƒ…å†µä¸‹ï¼Œå½“çº¿ç¨‹éœ€è¦ä»¥æŸç§ç‰¹å®šçš„é¡ºåºæ‰§è¡Œä»»åŠ¡æ—¶ï¼Œæ¯”å¦‚ä¸€ä¸ªçº¿ç¨‹ç”Ÿäº§æ•°æ®ï¼Œè€Œå¦ä¸€ä¸ªçº¿ç¨‹æ¶ˆè€—æ•°æ®æ—¶ï¼Œå¯ä»¥ä½¿ç”¨NSConditionLockï¼ˆæ¯”å¦‚å¸¸è§çš„ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ï¼‰ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªå®ä¾‹ï¼š

```swift
let NODATA = 1
let GOTDATA = 2
let clock = NSConditionLock(condition: NODATA)
var shareInt = 0

class ProducerThread: Thread {
        override func main() {
            for _ in 0..<100 {
                clock.lock(whenCondition: NODATA)
                LockFile.ProducerThread.sleep(forTimeInterval: 0.5)
                sharedInt = sharedInt + 1
                NSLog("ç”Ÿäº§è€…ï¼š\(sharedInt)")
                clock.unlock(withCondition: GOTDATA)
            }
        }
}
    
    class ConsumerThread: Thread {
        override func main() {
            for _ in 0..<100 {
                clock.lock(whenCondition: GOTDATA)
                sharedInt = sharedInt - 1
                NSLog("æ¶ˆè´¹è€…ï¼š\(sharedInt)")
                clock.unlock(withCondition: NODATA)
            }
        }
}

let pt = ProducerThread.init()
let ct = ConsumerThread.init()
pt.start()
ct.start()
```

å½“åˆ›å»ºä¸€ä¸ªæ¡ä»¶é”çš„æ—¶å€™ï¼Œéœ€è¦æŒ‡å®šä¸€ä¸ªç‰¹å®šIntç±»å‹çš„å€¼ã€‚è€Œ`lock(whenCondition:)`  æ–¹æ³•å½“æ¡ä»¶æ»¡è¶³æ—¶ä¼šè·å–è¿™ä¸ªé”ï¼Œæˆ–è€…æ¡ä»¶å’Œå¦ä¸€ä¸ªçº¿ç¨‹åœ¨ä½¿ç”¨`unlock(withCondition:)` é‡Šæ”¾é”æ—¶è®¾ç½®çš„å€¼æ»¡è¶³æ—¶ï¼Œ**NSConditionLock**å¯¹è±¡å°±ä¼šè·å–é”æ‰§è¡Œåç»­çš„ä»£ç ç‰‡æ®µï¼Œä½†æ˜¯å½“`lock(whenCondition:)` æ–¹æ³•æ²¡æœ‰è·å–é”çš„æ—¶å€™ï¼ˆæ¡ä»¶æ²¡æ»¡è¶³æ—¶ï¼‰ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šé˜»å¡çº¿ç¨‹çš„æ‰§è¡Œï¼Œç›´åˆ°è·å¾—é”ä¸ºæ­¢ã€‚

# NSCondition


NSConditionå’Œå‰è€…æ˜¯å¾ˆå®¹æ˜“æ··æ·†çš„ï¼Œä½†æ˜¯è¿™ä¸ªé”è§£å†³äº†ä»€ä¹ˆé—®é¢˜å‘¢ï¼Ÿ

å½“ä¸€ä¸ªå·²è·å¾—é”çš„çº¿ç¨‹å‘ç°æ‰§è¡Œå…¶å·¥ä½œæ‰€éœ€çš„é™„åŠ æ¡ä»¶ï¼ˆå®ƒéœ€è¦ä¸€äº›èµ„æºã€å¦ä¸€ä¸ªå¤„äºç‰¹å®šçŠ¶æ€çš„å¯¹è±¡ç­‰ï¼‰æš‚æ—¶è¿˜æ²¡æœ‰å¾—åˆ°æ»¡è¶³æ—¶ï¼Œå®ƒéœ€è¦ä¸€ç§æ–¹æ³•æ¥æš‚åœï¼Œå¹¶ä¸”ä¸€æ—¦æ»¡è¶³æ¡ä»¶å°±ç»§ç»­å·¥ä½œçš„æœºåˆ¶ï¼Œå¯æ˜¯å¦‚ä½•å®ç°å‘¢ï¼Ÿå¯ä»¥é€šè¿‡è¿ç»­çš„æ£€æŸ¥ï¼ˆå¿™ç­‰å¾…ï¼‰æ¥å®ç°ï¼Œä½†æ˜¯è¿™æ ·åšçš„è¯ï¼Œçº¿ç¨‹æŒæœ‰çš„é”ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬åº”è¯¥åœ¨ç­‰å¾…æ—¶ä¿ç•™å®ƒä»¬è¿˜æ˜¯é‡Šæ”¾å®ƒä»¬ï¼Ÿè¿˜æ˜¯åœ¨æ»¡è¶³æ¡ä»¶æ—¶å†æ¬¡è·å¾—å®ƒä»¬ï¼Ÿ

è€Œ**NSCondition**æä¾›äº†ä¸€ç§ç®€æ´çš„æ–¹å¼æ¥æä¾›äº†è¿™ç§é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Œä¸€æ—¦ä¸€ä¸ªçº¿ç¨‹è¢«æ”¾åœ¨è¯¥Conditionçš„ç­‰å¾…åˆ—è¡¨ä¸­ï¼Œå®ƒå¯ä»¥é€šè¿‡å¦ä¸€ä¸ªçº¿ç¨‹Signalæ¥å”¤é†’ã€‚ä»¥ä¸‹æ˜¯å…·ä½“çš„æ¡ˆä¾‹ï¼š

```swift
let cond = NSCondition.init()
var available = false
var sharedString = ""

class WriterThread: Thread {
        override func main() {
            for _ in 0..<100 {
                cond.lock()
                sharedString = "ğŸ¤£"
                available = true
                cond.signal()
                cond.unlock()
            }
        }
  }
    
  class PrinterThread: Thread {
        override func main() {
            for _ in 0..<100 {
                cond.lock()
                while (!available) {
                    cond.wait()
                }
                sharedString = ""
                available = false
                cond.unlock()
            }
        }
  }
```

å½“çº¿ç¨‹**waits**ä¸€ä¸ªæ¡ä»¶æ—¶ï¼Œè¿™ä¸ª**Condition**å¯¹è±¡ä¼š**unlock**å½“å‰é”å¹¶ä¸”é˜»å¡çº¿ç¨‹ã€‚å½“**Condition**å‘å‡ºä¿¡å·æ—¶ï¼Œç³»ç»Ÿä¼šå”¤é†’çº¿ç¨‹ï¼Œç„¶åè¿™ä¸ª**Condition**å¯¹è±¡ä¼šåœ¨wait()æˆ–è€…wait(until:)è¿”å›ä¹‹å‰ï¼Œè¿™ä¸ª**Condition**å¯¹è±¡ä¼šé‡æ–°è·å–åˆ°å®ƒçš„é”ï¼Œå› æ­¤ï¼Œä»çº¿ç¨‹çš„è§’åº¦æ¥çœ‹ï¼Œå®ƒä¼¼ä¹ä¸€ç›´æŒæœ‰è€…é”ï¼ˆè™½ç„¶ä¸­é€”å®ƒä¼šå¤±å»é”ï¼‰ã€‚

# Dispatch Semaphore

æœ€åæˆ‘ä»¬èŠä¸€èŠä¿¡å·é‡ï¼Œç®€è€Œè¨€ä¹‹ï¼Œä¿¡å·é‡æ˜¯éœ€è¦åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­è¿›è¡Œé”å®šå’Œè§£é”æ—¶ä½¿ç”¨çš„é”ã€‚å› ä¸ºå®ƒçš„waitæ–¹æ³•ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œæ‰€ä»¥éœ€è¦å…¶ä»–çº¿ç¨‹å‘æ¥signalä¿¡å·æ¥å”¤é†’å®ƒã€‚

```swift
let semaphore = DispatchSemaphore.init(value: 0)
DispatchQueue.global(qos: .userInitiated).async {
	  // to do some thing
		semaphore.signal()
}
semaphore.wait() // will block thread
```

å¦‚ä¸Šè¿°ä¾‹å­ä¸€æ ·ï¼Œä¿¡å·é‡é€šå¸¸ç”¨äºé”å®šä¸€ä¸ªçº¿ç¨‹ï¼Œç›´åˆ°å¦å¤–ä¸€ä¸ªçº¿ç¨‹ä¸­äº‹ä»¶çš„å®Œæˆåå‘å‡ºsignalä¿¡å·ã€‚ä»ä¸Šè¿°çš„æµ‹è¯•å›¾æ ‡ï¼Œä»¥åŠå…¶ä»–è¯¸å¤šæ–‡ç« ï¼Œä¿¡å·é‡çš„é€Ÿåº¦æ˜¯å¾ˆå¿«çš„ã€‚ä¸Šè¿°çš„ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ä¹Ÿå¯ä»¥ä½¿ç”¨ä¿¡å·é‡æ¥å®ç°ï¼š

```swift
let semaphore = DispatchSemaphore.init(value: 0)
        
 DispatchQueue.global(qos: .userInitiated).async {
        while true {
            sleep(1)
            sharedInt = sharedInt + 1
            NSLog("ç”Ÿäº§äº†: \(sharedInt)")
            _ = semaphore.signal()
        }
	}
        
  DispatchQueue.global(qos: .userInitiated).async {
        while true {
            if sharedInt <= 0 {
                _ = semaphore.wait(timeout: .distantFuture)
            } else {
                sharedInt = sharedInt - 1
                NSLog("æ¶ˆè€—äº†: \(sharedInt)")
            }
        }
    }
```

å¥½äº†ï¼Œç®€å•è¯´äº†ä¸€ä¸‹æˆ‘å¯¹äºé”çš„æ¢³ç†ï¼Œå¸Œæœ›å¤§å®¶ä¹Ÿå¯ä»¥ä»ä¸­å­¦åˆ°ä¸€ç‚¹ä¸œè¥¿å§ï½ å¦‚æœæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œæˆ–è€…é”™è¯¯å¸Œæœ›å¤§å®¶å¯ä»¥ç•™è¨€æŒ‡ç‚¹ã€‚

-   æˆ‘æ­£åœ¨å‚ä¸æ˜é‡‘æŠ€æœ¯ç¤¾åŒºåˆ›ä½œè€…ç­¾çº¦è®¡åˆ’æ‹›å‹Ÿæ´»åŠ¨ï¼Œ[ç‚¹å‡»é“¾æ¥æŠ¥åæŠ•ç¨¿](https://juejin.cn/post/7112770927082864653 "https://juejin.cn/post/7112770927082864653")ã€‚


# å‚è€ƒ

1ã€ã€Š[ä¸å†å®‰å…¨çš„OSSPinLock](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)ã€‹

2ã€[Apple Thread Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html)

3ã€[Concurrency in Swift](https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/#nsconditionlock)

4ã€[thread safety in swift](https://swiftrocks.com/thread-safety-in-swift)