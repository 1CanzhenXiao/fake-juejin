---
highlight: hybrid
---

### 1ã€å¡é¡¿åŸç†

#### 1.1ã€ç•Œé¢æ˜¾ç¤ºåŸç†
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/795e5ed914dc4e5b9757a0280cb44cdb~tplv-k3u1fbpfcp-watermark.image?)
- **CPU**ï¼š`Layout UI`å¸ƒå±€ã€æ–‡æœ¬è®¡ç®—ã€`Display`ç»˜åˆ¶ã€`Prepare`å›¾ç‰‡è§£ç ã€`Commit`æäº¤ä½å›¾ç»™ **GPU**

- **GPU**ï¼šç”¨äºæ¸²æŸ“ï¼Œå°†ç»“æœæ”¾å…¥ **FrameBuffer**

- `FrameBuffer`ï¼šå¸§ç¼“å†²

- **Video Controller**ï¼šæ ¹æ®`Vsync`ï¼ˆå‚ç›´åŒæ­¥ï¼‰ä¿¡å·ï¼Œé€è¡Œè¯»å– **FrameBuffer** ä¸­çš„æ•°æ®ï¼Œç»è¿‡æ•°æ¨¡è½¬æ¢ä¼ é€’ç»™ **Monitor** 

- **Monitor**ï¼šæ˜¾ç¤ºå™¨ï¼Œç”¨äºæ˜¾ç¤ºï¼›å¯¹äºæ˜¾ç¤ºæ¨¡å—æ¥è¯´ï¼Œä¼šæŒ‰ç…§æ‰‹æœºåˆ·æ–°ç‡ä»¥å›ºå®šçš„é¢‘ç‡ï¼š**1 / åˆ·æ–°ç‡** å‘ **FrameBuffer** ç´¢è¦æ•°æ®ï¼Œ**è¿™ä¸ªç´¢è¦æ•°æ®çš„å‘½ä»¤å°±æ˜¯ å‚ç›´åŒæ­¥ä¿¡å·Vsync**ï¼ˆä½åˆ·60å¸§ä¸º`16.67æ¯«ç§’`ï¼Œé«˜åˆ·120å¸§ä¸º **8.33æ¯«ç§’**ï¼Œä¸‹è¾¹ä¸¾ä¾‹ä¸»è¦ä»¥ä½åˆ·16.67æ¯«ç§’ä¸ºä¸»ï¼‰

#### 1.2ã€ç•Œé¢æ’•è£‚
æ˜¾ç¤ºç«¯æ¯16.67msä» **FrameBufferï¼ˆå¸§ç¼“å­˜åŒº**ï¼‰è¯»å–ä¸€å¸§æ•°æ®ï¼Œå¦‚æœé‡åˆ°è€—æ—¶æ“ä½œäº¤ä»˜ä¸äº†ï¼Œé‚£ä¹ˆå½“å‰ç”»é¢å°±è¿˜æ˜¯æ—§ä¸€å¸§çš„ç”»é¢ï¼Œä½†æ˜¾ç¤ºè¿‡ç¨‹ä¸­ï¼Œä¸‹ä¸€å¸§æ•°æ®å‡†å¤‡å®Œæ¯•ï¼Œå¯¼è‡´éƒ¨åˆ†æ˜¾ç¤ºçš„åˆæ˜¯æ–°æ•°æ®ï¼Œè¿™æ ·å°±ä¼šé€ æˆå±å¹•æ’•è£‚

#### 1.3ã€ç•Œé¢å¡é¡¿
- ä¸ºäº†è§£å†³ç•Œé¢æ’•è£‚ï¼Œè‹¹æœä½¿ç”¨`åŒç¼“å†²æœºåˆ¶ + å‚ç›´åŒæ­¥ä¿¡å·`ï¼Œä½¿ç”¨ **2ä¸ªFrameBuffer** å­˜å‚¨ **GPU** å¤„ç†ç»“æœï¼Œæ˜¾ç¤ºç«¯`äº¤æ›¿`ä»è¿™2ä¸ªFrameBufferä¸­è¯»å–æ•°æ®ï¼Œä¸€ä¸ªè¢«è¯»å–æ—¶å¦ä¸€ä¸ªå»ç¼“å­˜ï¼›ä½†è§£å†³ç•Œé¢æ’•è£‚çš„é—®é¢˜ä¹Ÿå¸¦æ¥äº†æ–°çš„é—®é¢˜ï¼š`æ‰å¸§`
    ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66adda1b79984803b3b290c3b582ff6a~tplv-k3u1fbpfcp-watermark.image?)
- å¦‚æœé‡åˆ°ç”»é¢å¸¦é©¬èµ›å…‹ç­‰æƒ…å†µï¼Œå¯¼è‡´GPUæ¸²æŸ“èƒ½åŠ›è·Ÿä¸ä¸Šï¼Œä¼šæœ‰2ç§æ‰å¸§æƒ…å†µï¼›å¦‚å›¾ï¼Œ**FrameBuffer2** æœªæ¸²æŸ“å®Œç¬¬2å¸§ï¼Œä¸‹ä¸€ä¸ª16.67mså» **FrameBuffer1** ä¸­æ‹¿ç¬¬3å¸§ï¼š
    - æ‰å¸§æƒ…å†µ1ï¼šç¬¬3å¸§æ¸²æŸ“å®Œæ¯•ï¼Œæ¥ä¸‹æ¥éœ€è¦ç¬¬4å¸§ï¼Œç¬¬2å¸§è¢«ä¸¢å¼ƒ
    - æ‰å¸§æƒ…å†µ2ï¼šç¬¬3å¸§æœªæ¸²æŸ“å®Œï¼Œå†ä¸€ä¸ª16.67mså» **FrameBuffer2** æ‹¿åˆ°ç¬¬2å¸§ï¼Œä½†ç¬¬1å¸§å¤šåœç•™äº†16.67*2æ¯«ç§’
    
#### å°ç»“
- å›ºå®šçš„æ—¶é—´é—´éš”ä¼šæ”¶åˆ°`å‚ç›´åŒæ­¥ä¿¡å·ï¼ˆVsyncï¼‰`ï¼Œå¦‚æœ **CPU** å’Œ **GPU** è¿˜æ²¡æœ‰å°†ä¸‹ä¸€å¸§æ•°æ®æ”¾åˆ°å¯¹åº”çš„å¸§ **FrameBufferç¼“å†²åŒº**ï¼Œå°±ä¼šå‡ºç° **æ‰å¸§**
    ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c753e57762b4ac3865e4870a36c2fc7~tplv-k3u1fbpfcp-watermark.image?)
    
### 2ã€å¡é¡¿æ£€æµ‹
#### 2.1ã€CADisplayLink
ç³»ç»Ÿåœ¨æ¯æ¬¡å‘é€ **VSync** æ—¶ï¼Œå°±ä¼šè§¦å‘`CADisplayLink`ï¼Œé€šè¿‡ç»Ÿè®¡æ¯ç§’å‘é€ **VSync** çš„æ•°é‡æ¥æŸ¥çœ‹ **App** çš„ **FPS** æ˜¯å¦ç¨³å®š
```swift
#import "ViewController.h"

@interface ViewController ()

@property (nonatomic, strong) CADisplayLink *link;
@property (nonatomic, assign) NSTimeInterval lastTime;Â  // æ¯éš”1ç§’è®°å½•ä¸€æ¬¡æ—¶é—´
@property (nonatomic, assign) NSUInteger count; Â  Â  Â  Â  // è®°å½•VSync1ç§’å†…å‘é€çš„æ•°é‡

@end

@implementation ViewController

- (void)viewDidLoad {
Â  Â  [super viewDidLoad];
Â  Â  self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkAction:)];
Â  Â  [_link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)linkAction: (CADisplayLink *)link {
Â  Â  if (_lastTime == 0) {
Â  Â  Â  Â  _lastTime = link.timestamp;
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  _count++;
Â  Â  NSTimeInterval delta = link.timestamp - _lastTime;
Â  Â  if (delta < 1) return;

Â  Â  _lastTime = link.timestamp;
Â  Â  float fps = _count / delta;
Â  Â  _count = 0;

Â  Â  NSLog(@"ğŸˆ FPS : %f ", fps);
}

@end
```

#### 2.2ã€RunLoopæ£€æµ‹
**RunLoop** çš„é€€å‡ºå’Œè¿›å…¥å®è´¨éƒ½æ˜¯`Observer`çš„é€šçŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç›‘å¬`Runloop`çš„çŠ¶æ€ï¼Œå¹¶åœ¨ç›¸å…³å›è°ƒé‡Œå‘é€ä¿¡å·ï¼Œå¦‚æœåœ¨`è®¾å®šçš„æ—¶é—´å†…`èƒ½å¤Ÿæ”¶åˆ°ä¿¡å·è¯´æ˜æ˜¯æµç•…çš„ï¼›å¦‚æœåœ¨è®¾å®šçš„æ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°ä¿¡å·ï¼Œè¯´æ˜å‘ç”Ÿäº†å¡é¡¿ã€‚

```swift
#import "LZBlockMonitor.h"

@interface LZBlockMonitor (){
Â  Â  CFRunLoopActivity activity;
}
@property (nonatomic, strong) dispatch_semaphore_t semaphore;
@property (nonatomic, assign) NSUInteger timeoutCount;

@end

@implementation LZBlockMonitor

+ (instancetype)sharedInstance {
Â  Â  static id instance = nil;
Â  Â  static dispatch_once_t onceToken;

    dispatch_once(&onceToken, ^{
Â  Â  Â  Â  instance = [[self alloc] init];
Â  Â  });
Â  Â  return instance;
}

- (void)start{
Â  Â  [self registerObserver];
Â  Â  [self startMonitor];
}

- (void)registerObserver{
Â  Â  CFRunLoopObserverContext context = {0, (__bridge void*)self, NULL, NULL};
Â  Â  //NSIntegerMax : ä¼˜å…ˆçº§æœ€å°
Â  Â  CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  kCFRunLoopAllActivities,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  YES,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  NSIntegerMax,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  &CallBack,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  &context);
Â  Â  CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
}

static void CallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
{
Â  Â  LZBlockMonitor *monitor = (__bridge LZBlockMonitor *)info;
Â  Â  monitor->activity = activity;
Â  Â  // å‘é€ä¿¡å·
Â  Â  dispatch_semaphore_t semaphore = monitor->_semaphore;
Â  Â  dispatch_semaphore_signal(semaphore);
}

- (void)startMonitor{
Â  Â  // åˆ›å»ºä¿¡å·
Â  Â  _semaphore = dispatch_semaphore_create(0);

Â  Â  // åœ¨å­çº¿ç¨‹ç›‘æ§æ—¶é•¿
Â  Â  dispatch_async(dispatch_get_global_queue(0, 0), ^{
Â  Â  Â  Â  while (YES)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  // è¶…æ—¶æ—¶é—´æ˜¯ 1 ç§’ï¼Œæ²¡æœ‰ç­‰åˆ°ä¿¡å·é‡ï¼Œst å°±ä¸ç­‰äº 0ï¼Œ RunLoop æ‰€æœ‰çš„ä»»åŠ¡
Â  Â  Â  Â  Â  Â  long st = dispatch_semaphore_wait(self->_semaphore, dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC));
Â  Â  Â  Â  Â  Â  if (st != 0)
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  if (self->activity == kCFRunLoopBeforeSources || self->activity == kCFRunLoopAfterWaiting)
Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (++self->_timeoutCount < 2){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  NSLog(@"timeoutCount==%lu",(unsigned long)self->_timeoutCount);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ä¸€ç§’å·¦å³çš„è¡¡é‡å°ºåº¦ å¾ˆå¤§å¯èƒ½æ€§è¿ç»­æ¥ é¿å…å¤§è§„æ¨¡æ‰“å°!
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  NSLog(@"æ£€æµ‹åˆ°è¶…è¿‡ä¸¤æ¬¡è¿ç»­å¡é¡¿");
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  self->_timeoutCount = 0;
Â  Â  Â  Â  }
Â  Â  });
}

@end
```
- ä¸»çº¿ç¨‹ç›‘å¬ `kCFRunLoopBeforeSources`ï¼ˆå³å°†å¤„ç†äº‹ä»¶ï¼‰å’Œ`kCFRunLoopAfterWaiting`ï¼ˆå³å°†ä¼‘çœ ï¼‰ï¼Œå­çº¿ç¨‹ç›‘æ§æ—¶é•¿ï¼Œè‹¥è¿ç»­ä¸¤æ¬¡ **1ç§’** å†…æ²¡æœ‰æ”¶åˆ°ä¿¡å·ï¼Œè¯´æ˜å‘ç”Ÿäº†å¡é¡¿

#### 2.3ã€å¾®ä¿¡matrix
- å¾®ä¿¡çš„`matrix`ä¹Ÿæ˜¯å€ŸåŠ© **runloop** å®ç°ï¼Œå¤§ä½“æµç¨‹ä¸ä¸Šé¢ **Runloop** æ–¹å¼ç›¸åŒï¼Œå®ƒä½¿ç”¨`é€€ç«ç®—æ³•`ä¼˜åŒ–æ•è·å¡é¡¿çš„æ•ˆç‡ï¼Œé˜²æ­¢è¿ç»­æ•è·ç›¸åŒçš„å¡é¡¿ï¼Œå¹¶ä¸”é€šè¿‡ä¿å­˜æœ€è¿‘çš„`20`ä¸ªä¸»çº¿ç¨‹å †æ ˆä¿¡æ¯ï¼Œè·å–æœ€è¿‘æœ€è€—æ—¶å †æ ˆ

#### 2.4ã€æ»´æ»´DoraemonKit
- `DoraemonKit`çš„å¡é¡¿æ£€æµ‹æ–¹æ¡ˆä¸ä½¿ç”¨ **RunLoop**ï¼Œå®ƒä¹Ÿæ˜¯`while`å¾ªç¯ä¸­æ ¹æ®ä¸€å®šçš„çŠ¶æ€åˆ¤æ–­ï¼Œé€šè¿‡ä¸»çº¿ç¨‹ä¸­ä¸æ–­å‘é€ä¿¡å·`semaphore`ï¼Œå¾ªç¯ä¸­ç­‰å¾…ä¿¡å·çš„æ—¶é—´ä¸º`5ç§’`ï¼Œç­‰å¾…è¶…æ—¶åˆ™è¯´æ˜ä¸»çº¿ç¨‹å¡é¡¿ï¼Œå¹¶è¿›è¡Œç›¸å…³ä¸ŠæŠ¥

### 3ã€ä¼˜åŒ–æ–¹æ³•
å¹³æ—¶ç®€å•çš„æ–¹æ¡ˆæœ‰ï¼š
- é¿å…ä½¿ç”¨ **é€æ˜UIView**
- å°½é‡ä½¿ç”¨`PNG`å›¾ç‰‡
- é¿å…ç¦»å±æ¸²æŸ“ï¼ˆåœ†è§’ä½¿ç”¨è´å¡å°”æ›²çº¿ç­‰ï¼‰

#### 3.1ã€é¢„æ’ç‰ˆ
- å°±æ˜¯å¸¸è§„çš„åœ¨Modelå±‚è¯·æ±‚æ•°æ®åæå‰å°†cellé«˜åº¦ç®—å¥½

#### 3.2ã€é¢„ç¼–ç  / è§£ç 
- **UIImage** æ˜¯ä¸€ä¸ª`Model`ï¼Œ**äºŒè¿›åˆ¶æµæ•°æ®** å­˜å‚¨åœ¨`DataBuffer`ä¸­ï¼Œç»è¿‡`decode`è§£ç ï¼ŒåŠ è½½åˆ°`imageBuffer`ä¸­ï¼Œæœ€ç»ˆè¿›å…¥`FrameBuffer`æ‰èƒ½è¢«æ¸²æŸ“
    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b730c9a2d74c43f4b51a38e42177d3bd~tplv-k3u1fbpfcp-watermark.image?)
- å½“ä½¿ç”¨ **UIImage** æˆ–`CGImageSource`çš„æ–¹æ³•åˆ›å»ºå›¾ç‰‡æ—¶ï¼Œå›¾ç‰‡çš„æ•°æ®ä¸ä¼šç«‹å³è§£ç ï¼Œè€Œæ˜¯åœ¨è®¾ç½®`UIImageView.image`æ—¶è§£ç 

- å°†å›¾ç‰‡è®¾ç½®åˆ°`UIImageView/CALayer.contents`ä¸­ï¼Œç„¶ååœ¨`CALayer`æäº¤è‡³`GPU`æ¸²æŸ“å‰ï¼Œ`CGImage`ä¸­çš„æ•°æ®æ‰è¿›è¡Œè§£ç 

- å¦‚æœä»»ç”±ç³»ç»Ÿå¤„ç†ï¼Œè¿™ä¸€æ­¥åˆ™æ— æ³•é¿å…ï¼Œå¹¶ä¸”ä¼šå‘ç”Ÿåœ¨ä¸»çº¿ç¨‹ä¸­ã€‚å¦‚æœæƒ³é¿å…è¿™ä¸ªæœºåˆ¶ï¼Œåœ¨å­çº¿ç¨‹å…ˆå°†å›¾ç‰‡ç»˜åˆ¶åˆ°`CGBitmapContext`ï¼Œç„¶åä»`Bitmap`ä¸­åˆ›å»ºå›¾ç‰‡

#### 3.3ã€æŒ‰éœ€åŠ è½½
- å¦‚æœç›®æ ‡è¡Œä¸å½“å‰è¡Œç›¸å·®è¶…è¿‡æŒ‡å®šè¡Œæ•°ï¼ŒåªåŠ è½½ç›®æ ‡æ»šåŠ¨èŒƒå›´çš„å‰åæŒ‡å®š`3è¡Œ`
    ```swift
    - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{
        [needLoadArr removeAllObjects];
    }

    - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset{
        NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset->y)];
        NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];
        NSInteger skipCount = 8;
        if (labs(cip.row-ip.row)>skipCount) {
            NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset->y, self.width, self.height)];
            NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];
            if (velocity.y<0) {
                NSIndexPath *indexPath = [temp lastObject];
                if (indexPath.row+3<datas.count) {
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+1 inSection:0]];
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+2 inSection:0]];
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row+3 inSection:0]];
                }
            } else {
                NSIndexPath *indexPath = [temp firstObject];
                if (indexPath.row>3) {
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];
                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];
                }
            }
            [needLoadArr addObjectsFromArray:arr];
        }
    }
    ```
- åœ¨æ»‘åŠ¨ç»“æŸæ—¶è¿›è¡Œ **Cell** çš„æ¸²æŸ“    
    ```swift
    - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView{
        scrollToToping = YES;
        return YES;
    }

    - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView{
        scrollToToping = NO;
        [self loadContent];
    }

    - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView{
        scrollToToping = NO;
        [self loadContent];
    }

    //ç”¨æˆ·è§¦æ‘¸æ—¶ç¬¬ä¸€æ—¶é—´åŠ è½½å†…å®¹
    - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
        if (!scrollToToping) {
            [needLoadArr removeAllObjects];
            [self loadContent];
        }
        return [super hitTest:point withEvent:event];
    }

    - (void)loadContent{
        if (scrollToToping) {
            return;
        }
        if (self.indexPathsForVisibleRows.count<=0) {
            return;
        }
        if (self.visibleCells && self.visibleCells.count>0) {
            for (id temp in [self.visibleCells copy]) {
                VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;
                [cell draw];
            }
        }
    }
    ```
- è¿™ç§æ–¹å¼ä¼šå¯¼è‡´æ»‘åŠ¨æ—¶æœ‰ç©ºç™½å†…å®¹ï¼Œå› æ­¤è¦åšå¥½å ä½å†…å®¹

#### 3.4ã€`å¼‚æ­¥æ¸²æŸ“`
- **å¼‚æ­¥æ¸²æŸ“** å°±æ˜¯åœ¨å­çº¿ç¨‹æŠŠéœ€è¦ç»˜åˆ¶çš„å›¾å½¢æå‰å¤„ç†å¥½ï¼Œç„¶åå°†å¤„ç†å¥½çš„å›¾åƒæ•°æ®ç›´æ¥è¿”ç»™ä¸»çº¿ç¨‹ä½¿ç”¨
- å¼‚æ­¥æ¸²æŸ“æ“ä½œçš„æ˜¯`layer`å±‚ï¼Œå°†å¤šå±‚å †å çš„æ§ä»¶ä»¬é€šè¿‡`UIGraphics`ç”»æˆä¸€å¼ `ä½å›¾`ï¼Œç„¶åå±•ç¤ºåœ¨`layer.content`ä¸Š

##### 3.4.1ã€CALayer
- `CALayer`åŸºäº`CoreAnimation`è¿›è€ŒåŸºäº`QuartzCode`ï¼Œåªè´Ÿè´£æ˜¾ç¤ºï¼Œä¸”æ˜¾ç¤ºçš„æ˜¯`ä½å›¾`ï¼Œä¸èƒ½å¤„ç†ç”¨æˆ·çš„è§¦æ‘¸äº‹ä»¶
- ä¸éœ€è¦ä¸ç”¨æˆ·äº¤äº’æ—¶ï¼Œä½¿ç”¨ **UIView** å’Œ **CALayer** éƒ½å¯ä»¥ï¼Œç”šè‡³ **CALayer** æ›´ç®€æ´é«˜æ•ˆ

##### 3.4.2ã€å¼‚æ­¥æ¸²æŸ“å®ç°
- å¼‚æ­¥æ¸²æŸ“çš„æ¡†æ¶æ¨èï¼š`Graver`ã€`YYAsyncLayer`
- **CALayer** åœ¨è°ƒç”¨`display`æ–¹æ³•åå›å»è°ƒç”¨ç»˜åˆ¶ç›¸å…³çš„æ–¹æ³•ï¼Œç»˜åˆ¶ä¼šæ‰§è¡Œ`drawRect:`æ–¹æ³•

##### ç®€å•ä¾‹å­
- ç»§æ‰¿ **CALayer**
    ```swift
    #import "LZLayer.h"

    @implementation LZLayer

    //å‰é¢æ–­ç‚¹è°ƒç”¨å†™ä¸‹çš„ä»£ç 
    - (void)layoutSublayers{
        if (self.delegate && [self.delegate respondsToSelector:@selector(layoutSublayersOfLayer:)]) {
            //UIView
            [self.delegate layoutSublayersOfLayer:self];
        }else{
            [super layoutSublayers];
        }
    }

    //ç»˜åˆ¶æµç¨‹çš„å‘èµ·å‡½æ•°
    - (void)display{
        // Graver å®ç°æ€è·¯
        CGContextRef context = (__bridge CGContextRef)([self.delegate performSelector:@selector(createContext)]);
        [self.delegate layerWillDraw:self];
        [self drawInContext:context];
        [self.delegate displayLayer:self];
        [self.delegate performSelector:@selector(closeContext)];
    }

    @end
    ```
- ç»§æ‰¿ **UIView**
    ```swift
    // - (CGContextRef)createContext å’Œ - (void)closeContextè¦åœ¨.hä¸­å£°æ˜
    #import "LZView.h"
    #import "LZLayer.h"

    @implementation LZView

    - (void)drawRect:(CGRect)rect {
        // Drawing codeï¼Œ ç»˜åˆ¶çš„æ“ä½œï¼Œ BackingStore(é¢å¤–çš„å­˜å‚¨åŒºåŸŸäº§äºçš„) -- GPU
    }

    //å­è§†å›¾çš„å¸ƒå±€
    - (void)layoutSubviews{
        [super layoutSubviews];
    }

    + (Class)layerClass{
        return [LZLayer class];
    }

    //
    - (void)layoutSublayersOfLayer:(CALayer *)layer{
        [super layoutSublayersOfLayer:layer];
        [self layoutSubviews];
    }

    - (CGContextRef)createContext{
        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.layer.opaque, self.layer.contentsScale);
        CGContextRef context = UIGraphicsGetCurrentContext();
        return context;
    }

    - (void)layerWillDraw:(CALayer *)layer{
        //ç»˜åˆ¶çš„å‡†å¤‡å·¥ä½œ,do nontihing
    }

    //ç»˜åˆ¶çš„æ“ä½œ
    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{
        [super drawLayer:layer inContext:ctx];

        // ç”»ä¸ªä¸è§„åˆ™å›¾å½¢
        CGContextMoveToPoint(ctx, self.bounds.size.width / 2- 20, 20);
        CGContextAddLineToPoint(ctx, self.bounds.size.width / 2 + 20, 20);
        CGContextAddLineToPoint(ctx, self.bounds.size.width / 2 + 40, 80);
        CGContextAddLineToPoint(ctx, self.bounds.size.width / 2 - 40, 100);
        CGContextAddLineToPoint(ctx, self.bounds.size.width / 2 - 20, 20);
        CGContextSetFillColorWithColor(ctx, UIColor.magentaColor.CGColor);
        CGContextSetStrokeColorWithColor(ctx, UIColor.magentaColor.CGColor); // æè¾¹

        CGContextDrawPath(ctx, kCGPathFillStroke);

        // ç”»ä¸ªçº¢è‰²æ–¹å—
        [[UIColor redColor] set];
           //Core Graphics
        UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(self.bounds.size.width / 2- 20, self.bounds.size.height / 2- 20, 40, 40)];
        CGContextAddPath(ctx, path.CGPath);
        CGContextFillPath(ctx);

        // æ–‡å­—
        [@"LZ" drawInRect:CGRectMake(self.bounds.size.width / 2 - 40, 100, 80, 24) withAttributes:@{NSFontAttributeName: [UIFont systemFontOfSize:20],NSForegroundColorAttributeName: UIColor.blueColor}];
        // å›¾ç‰‡
        [[UIImage imageWithContentsOfFile:@"/Volumes/Disk_D/test code/Test/Test/yasuo.png"] drawInRect:CGRectMake(10, self.bounds.size.height/2, self.bounds.size.widthÂ  - 20, self.bounds.size.height/2 -10)];
    }

    //layer.contents = (ä½å›¾)
    - (void)displayLayer:(CALayer *)layer{
        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
        dispatch_async(dispatch_get_main_queue(), ^{
            layer.contents = (__bridge id)(image.CGImage);
        });
    }

    - (void)closeContext{
        UIGraphicsEndImageContext();
    }
    ```

- æ§ä»¶ä»¬è¢«ç»˜åˆ¶æˆäº†ä¸€å¼ å›¾
    ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ba218bfd0647c89e7f7255cc4a2e80~tplv-k3u1fbpfcp-watermark.image?)

- æ­¤å¤–ï¼Œè™½ç„¶å°†æ§ä»¶ç”»åˆ°ä¸€å¼ ä½å›¾ä¸Šï¼Œä½†æ˜¯è¿˜æœ‰é—®é¢˜ï¼Œå°±æ˜¯æ§ä»¶çš„äº¤äº’äº‹ä»¶ï¼Œå†…å®¹è¾ƒå¤šå»ºè®®é’»ç ”ä¸€ä¸‹graverçš„æºç 










